--- libavcodec/ac3.c       2007-09-14 00:02:17.000000000 +0200
+++ libavcodec/ac3.c  2007-09-14 00:03:58.000000000 +0200
@@ -173,7 +173,7 @@
 }

 void ff_ac3_bit_alloc_calc_bap(int16_t *mask, int16_t *psd, int start, int end,
-                               int snroffset, int floor, uint8_t *bap)
+                               int snroffset, int floor, const uint8_t *baptab, uint8_t *bap)
 {
     int i, j, k, end1, v, address;

@@ -190,7 +190,7 @@
         end1 = FFMIN(bndtab[j] + ff_ac3_bndsz[j], end);
         for (k = i; k < end1; k++) {
             address = av_clip((psd[i] - v) >> 5, 0, 63);
-            bap[i] = ff_ac3_baptab[address];
+            bap[i] = baptab[address];
             i++;
         }
     } while (end > bndtab[j++]);
@@ -215,7 +215,7 @@
                                deltbae, deltnseg, deltoffst, deltlen, deltba,
                                mask);

-    ff_ac3_bit_alloc_calc_bap(mask, psd, start, end, snroffset, s->floor, bap);
+    ff_ac3_bit_alloc_calc_bap(mask, psd, start, end, snroffset, s->floor, ff_ac3_baptab, bap);
 }

 /**

--- libavcodec/ac3.h       2007-09-14 00:02:17.000000000 +0200
+++ libavcodec/ac3.h  2007-09-14 00:03:58.000000000 +0200
@@ -161,10 +161,11 @@
  * @param[in]  end        ending bin location
  * @param[in]  snroffset  SNR adjustment
  * @param[in]  floor      noise floor
+ * @param[in]  baptab     bit allocation pointer table
  * @param[out] bap        bit allocation pointers
  */
 void ff_ac3_bit_alloc_calc_bap(int16_t *mask, int16_t *psd, int start, int end,
-                               int snroffset, int floor, uint8_t *bap);
+                               int snroffset, int floor, const uint8_t *baptab, uint8_t *bap);

 void ac3_parametric_bit_allocation(AC3BitAllocParameters *s, uint8_t *bap,
                                    int8_t *exp, int start, int end,

 
--- libavcodec/ac3dec.c	2007-09-26 18:04:18.000000000 +0200
+++ libavcodec/ac3dec.c	2007-09-26 18:15:19.000000000 +0200
@@ -37,29 +37,24 @@
 #include "bitstream.h"
 #include "dsputil.h"
 #include "random.h"
-
-/**
- * Table of bin locations for rematrixing bands
- * reference: Section 7.5.2 Rematrixing : Frequency Band Definitions
- */
-static const uint8_t rematrix_band_tab[5] = { 13, 25, 37, 61, 253 };
+#include "ac3dec.h"
 
 /**
  * table for exponent to scale_factor mapping
- * scale_factors[i] = 2 ^ -i
+ * ff_ac3_scale_factors[i] = 2 ^ -i
  */
-static float scale_factors[25];
+float ff_ac3_scale_factors[25];
 
 /** table for grouping exponents */
-static uint8_t exp_ungroup_tab[128][3];
+uint8_t ff_ac3_exp_ungroup_tbl[128][3];
 
 
 /** tables for ungrouping mantissas */
-static float b1_mantissas[32][3];
-static float b2_mantissas[128][3];
-static float b3_mantissas[8];
-static float b4_mantissas[128][2];
-static float b5_mantissas[16];
+float ff_ac3_b1_mantissas[32][3];
+float ff_ac3_b2_mantissas[128][3];
+float ff_ac3_b3_mantissas[8];
+float ff_ac3_b4_mantissas[128][2];
+float ff_ac3_b5_mantissas[16];
 
 /**
  * Quantization table: levels for symmetric. bits for asymmetric.
@@ -71,18 +66,10 @@
 };
 
 /** dynamic range table. converts codes to scale factors. */
-static float dynrng_tab[256];
+float ff_ac3_dynrng_tbl[256];
 
 /** dialogue normalization table */
-static float dialnorm_tab[32];
-
-/** Adjustments in dB gain */
-#define LEVEL_MINUS_3DB         0.7071067811865476
-#define LEVEL_MINUS_4POINT5DB   0.5946035575013605
-#define LEVEL_MINUS_6DB         0.5000000000000000
-#define LEVEL_MINUS_9DB         0.3535533905932738
-#define LEVEL_ZERO              0.0000000000000000
-#define LEVEL_ONE               1.0000000000000000
+float ff_ac3_dialnorm_tbl[32];
 
 static const float gain_levels[6] = {
     LEVEL_ZERO,
@@ -123,7 +110,6 @@
 /* override ac3.h to include coupling channel */
 #undef AC3_MAX_CHANNELS
 #define AC3_MAX_CHANNELS 7
-#define CPL_CH 0
 
 #define AC3_OUTPUT_LFEON  8
 
@@ -201,7 +187,7 @@
 /**
  * Generate a Kaiser-Bessel Derived Window.
  */
-static void ac3_window_init(float *window)
+void ff_ac3_window_init(float *window)
 {
    int i, j;
    double sum = 0.0, bessel, tmp;
@@ -236,7 +222,7 @@
 /*
  * Initialize tables at runtime.
  */
-static void ac3_tables_init(void)
+void ff_ac3_tables_init(void)
 {
     int i;
 
@@ -244,57 +230,57 @@
        reference: Section 7.3.5 Ungrouping of Mantissas */
     for(i=0; i<32; i++) {
         /* bap=1 mantissas */
-        b1_mantissas[i][0] = symmetric_dequant( i / 9     , 3);
-        b1_mantissas[i][1] = symmetric_dequant((i % 9) / 3, 3);
-        b1_mantissas[i][2] = symmetric_dequant((i % 9) % 3, 3);
+        ff_ac3_b1_mantissas[i][0] = symmetric_dequant( i / 9     , 3);
+        ff_ac3_b1_mantissas[i][1] = symmetric_dequant((i % 9) / 3, 3);
+        ff_ac3_b1_mantissas[i][2] = symmetric_dequant((i % 9) % 3, 3);
     }
     for(i=0; i<128; i++) {
         /* bap=2 mantissas */
-        b2_mantissas[i][0] = symmetric_dequant( i / 25     , 5);
-        b2_mantissas[i][1] = symmetric_dequant((i % 25) / 5, 5);
-        b2_mantissas[i][2] = symmetric_dequant((i % 25) % 5, 5);
+        ff_ac3_b2_mantissas[i][0] = symmetric_dequant( i / 25     , 5);
+        ff_ac3_b2_mantissas[i][1] = symmetric_dequant((i % 25) / 5, 5);
+        ff_ac3_b2_mantissas[i][2] = symmetric_dequant((i % 25) % 5, 5);
 
         /* bap=4 mantissas */
-        b4_mantissas[i][0] = symmetric_dequant(i / 11, 11);
-        b4_mantissas[i][1] = symmetric_dequant(i % 11, 11);
+        ff_ac3_b4_mantissas[i][0] = symmetric_dequant(i / 11, 11);
+        ff_ac3_b4_mantissas[i][1] = symmetric_dequant(i % 11, 11);
     }
     /* generate ungrouped mantissa tables
        reference: Tables 7.21 and 7.23 */
     for(i=0; i<7; i++) {
         /* bap=3 mantissas */
-        b3_mantissas[i] = symmetric_dequant(i, 7);
+        ff_ac3_b3_mantissas[i] = symmetric_dequant(i, 7);
     }
     for(i=0; i<15; i++) {
         /* bap=5 mantissas */
-        b5_mantissas[i] = symmetric_dequant(i, 15);
+        ff_ac3_b5_mantissas[i] = symmetric_dequant(i, 15);
     }
 
     /* generate dynamic range table
        reference: Section 7.7.1 Dynamic Range Control */
     for(i=0; i<256; i++) {
         int v = (i >> 5) - ((i >> 7) << 3) - 5;
-        dynrng_tab[i] = powf(2.0f, v) * ((i & 0x1F) | 0x20);
+        ff_ac3_dynrng_tbl[i] = powf(2.0f, v) * ((i & 0x1F) | 0x20);
     }
 
     /* generate dialogue normalization table
        references: Section 5.4.2.8 dialnorm
                    Section 7.6 Dialogue Normalization */
     for(i=1; i<32; i++) {
-        dialnorm_tab[i] = expf((i-31) * M_LN10 / 20.0f);
+        ff_ac3_dialnorm_tbl[i] = expf((i-31) * M_LN10 / 20.0f);
     }
-    dialnorm_tab[0] = dialnorm_tab[31];
+    ff_ac3_dialnorm_tbl[0] = ff_ac3_dialnorm_tbl[31];
 
     /* generate scale factors for exponents and asymmetrical dequantization
        reference: Section 7.3.2 Expansion of Mantissas for Asymmetric Quantization */
     for (i = 0; i < 25; i++)
-        scale_factors[i] = pow(2.0, -i);
+        ff_ac3_scale_factors[i] = pow(2.0, -i);
 
     /* generate exponent tables
        reference: Section 7.1.3 Exponent Decoding */
     for(i=0; i<128; i++) {
-        exp_ungroup_tab[i][0] =  i / 25;
-        exp_ungroup_tab[i][1] = (i % 25) / 5;
-        exp_ungroup_tab[i][2] = (i % 25) % 5;
+        ff_ac3_exp_ungroup_tbl[i][0] =  i / 25;
+        ff_ac3_exp_ungroup_tbl[i][1] = (i % 25) / 5;
+        ff_ac3_exp_ungroup_tbl[i][2] = (i % 25) % 5;
     }
 }
 
@@ -308,10 +294,10 @@
     ctx->avctx = avctx;
 
     ac3_common_init();
-    ac3_tables_init();
+    ff_ac3_tables_init();
     ff_mdct_init(&ctx->imdct_256, 8, 1);
     ff_mdct_init(&ctx->imdct_512, 9, 1);
-    ac3_window_init(ctx->window);
+    ff_ac3_window_init(ctx->window);
     dsputil_init(&ctx->dsp, avctx);
     av_init_random(0, &ctx->dith_state);
 
@@ -382,7 +368,7 @@
     /* read the rest of the bsi. read twice for dual mono mode. */
     i = !(ctx->acmod);
     do {
-        ctx->dialnorm[i] = dialnorm_tab[get_bits(gb, 5)]; // dialogue normalization
+        ctx->dialnorm[i] = ff_ac3_dialnorm_tbl[get_bits(gb, 5)]; // dialogue normalization
         if (get_bits1(gb))
             skip_bits(gb, 8); //skip compression
         if (get_bits1(gb))
@@ -433,7 +419,7 @@
  * Decode the grouped exponents according to exponent strategy.
  * reference: Section 7.1.3 Exponent Decoding
  */
-static void decode_exponents(GetBitContext *gb, int expstr, int ngrps,
+void ff_ac3_decode_exponents(GetBitContext *gb, int expstr, int ngrps,
                              uint8_t absexp, int8_t *dexps)
 {
     int i, j, grp, grpsize;
@@ -444,9 +430,9 @@
     grpsize = expstr + (expstr == EXP_D45);
     for(grp=0,i=0; grp<ngrps; grp++) {
         expacc = get_bits(gb, 7);
-        dexp[i++] = exp_ungroup_tab[expacc][0];
-        dexp[i++] = exp_ungroup_tab[expacc][1];
-        dexp[i++] = exp_ungroup_tab[expacc][2];
+        dexp[i++] = ff_ac3_exp_ungroup_tbl[expacc][0];
+        dexp[i++] = ff_ac3_exp_ungroup_tbl[expacc][1];
+        dexp[i++] = ff_ac3_exp_ungroup_tbl[expacc][2];
     }
 
     /* convert to absolute exps and expand groups */
@@ -485,48 +471,28 @@
 }
 
 /**
- * Grouped mantissas for 3-level 5-level and 11-level quantization
- */
-typedef struct {
-    float b1_mant[3];
-    float b2_mant[3];
-    float b4_mant[2];
-    int b1ptr;
-    int b2ptr;
-    int b4ptr;
-} mant_groups;
-
-/**
  * Get the transform coefficients for a particular channel
  * reference: Section 7.3 Quantization and Decoding of Mantissas
  */
-static int get_transform_coeffs_ch(AC3DecodeContext *ctx, int ch_index, mant_groups *m)
+int ff_ac3_get_transform_coeffs_ch(mant_groups *m, GetBitContext *gb,
+        uint8_t *exps, uint8_t *bap, float *coeffs, int start, int end,
+        AVRandomState *dith_state)
 {
-    GetBitContext *gb = &ctx->gb;
-    int i, gcode, tbap, start, end;
-    uint8_t *exps;
-    uint8_t *bap;
-    float *coeffs;
-
-    exps = ctx->dexps[ch_index];
-    bap = ctx->bap[ch_index];
-    coeffs = ctx->transform_coeffs[ch_index];
-    start = ctx->startmant[ch_index];
-    end = ctx->endmant[ch_index];
+    int i, gcode, tbap;
 
     for (i = start; i < end; i++) {
         tbap = bap[i];
         switch (tbap) {
             case 0:
-                coeffs[i] = ((av_random(&ctx->dith_state) & 0xFFFF) / 65535.0f) - 0.5f;
+                coeffs[i] = ((av_random(dith_state) & 0xFFFF) * LEVEL_MINUS_3DB) / 32768.0f;
                 break;
 
             case 1:
                 if(m->b1ptr > 2) {
                     gcode = get_bits(gb, 5);
-                    m->b1_mant[0] = b1_mantissas[gcode][0];
-                    m->b1_mant[1] = b1_mantissas[gcode][1];
-                    m->b1_mant[2] = b1_mantissas[gcode][2];
+                    m->b1_mant[0] = ff_ac3_b1_mantissas[gcode][0];
+                    m->b1_mant[1] = ff_ac3_b1_mantissas[gcode][1];
+                    m->b1_mant[2] = ff_ac3_b1_mantissas[gcode][2];
                     m->b1ptr = 0;
                 }
                 coeffs[i] = m->b1_mant[m->b1ptr++];
@@ -535,38 +501,38 @@
             case 2:
                 if(m->b2ptr > 2) {
                     gcode = get_bits(gb, 7);
-                    m->b2_mant[0] = b2_mantissas[gcode][0];
-                    m->b2_mant[1] = b2_mantissas[gcode][1];
-                    m->b2_mant[2] = b2_mantissas[gcode][2];
+                    m->b2_mant[0] = ff_ac3_b2_mantissas[gcode][0];
+                    m->b2_mant[1] = ff_ac3_b2_mantissas[gcode][1];
+                    m->b2_mant[2] = ff_ac3_b2_mantissas[gcode][2];
                     m->b2ptr = 0;
                 }
                 coeffs[i] = m->b2_mant[m->b2ptr++];
                 break;
 
             case 3:
-                coeffs[i] = b3_mantissas[get_bits(gb, 3)];
+                coeffs[i] = ff_ac3_b3_mantissas[get_bits(gb, 3)];
                 break;
 
             case 4:
                 if(m->b4ptr > 1) {
                     gcode = get_bits(gb, 7);
-                    m->b4_mant[0] = b4_mantissas[gcode][0];
-                    m->b4_mant[1] = b4_mantissas[gcode][1];
+                    m->b4_mant[0] = ff_ac3_b4_mantissas[gcode][0];
+                    m->b4_mant[1] = ff_ac3_b4_mantissas[gcode][1];
                     m->b4ptr = 0;
                 }
                 coeffs[i] = m->b4_mant[m->b4ptr++];
                 break;
 
             case 5:
-                coeffs[i] = b5_mantissas[get_bits(gb, 4)];
+                coeffs[i] = ff_ac3_b5_mantissas[get_bits(gb, 4)];
                 break;
 
             default:
                 /* asymmetric dequantization */
-                coeffs[i] = get_sbits(gb, qntztab[tbap]) * scale_factors[qntztab[tbap]-1];
+                coeffs[i] = get_sbits(gb, qntztab[tbap]) * ff_ac3_scale_factors[qntztab[tbap]-1];
                 break;
         }
-        coeffs[i] *= scale_factors[exps[i]];
+        coeffs[i] *= ff_ac3_scale_factors[exps[i]];
     }
 
     return 0;
@@ -618,13 +584,19 @@
 
     for (ch = 1; ch <= ctx->nchans; ch++) {
         /* transform coefficients for full-bandwidth channel */
-        if (get_transform_coeffs_ch(ctx, ch, &m))
+        if (ff_ac3_get_transform_coeffs_ch(&m, &ctx->gb, ctx->dexps[ch],
+                    ctx->bap[ch], ctx->transform_coeffs[ch], ctx->startmant[ch],
+                    ctx->endmant[ch], &ctx->dith_state))
             return -1;
         /* tranform coefficients for coupling channel come right after the
            coefficients for the first coupled channel*/
         if (ctx->chincpl[ch])  {
             if (!got_cplchan) {
-                if (get_transform_coeffs_ch(ctx, CPL_CH, &m)) {
+                if (ff_ac3_get_transform_coeffs_ch(&m, &ctx->gb,
+                            ctx->dexps[CPL_CH], ctx->bap[CPL_CH],
+                            ctx->transform_coeffs[CPL_CH],
+                            ctx->startmant[CPL_CH], ctx->endmant[CPL_CH],
+                            &ctx->dith_state)){
                     av_log(ctx->avctx, AV_LOG_ERROR, "error in decoupling channels\n");
                     return -1;
                 }
@@ -651,22 +623,20 @@
  * Stereo rematrixing.
  * reference: Section 7.5.4 Rematrixing : Decoding Technique
  */
-static void do_rematrixing(AC3DecodeContext *ctx)
+void ff_ac3_do_rematrixing(float (*transform_coeffs)[256], int end, int nrematbnd, int *rematflg)
 {
     int bnd, i;
-    int end, bndend;
+    int bndend;
     float tmp0, tmp1;
 
-    end = FFMIN(ctx->endmant[1], ctx->endmant[2]);
-
-    for(bnd=0; bnd<ctx->nrematbnd; bnd++) {
-        if(ctx->rematflg[bnd]) {
-            bndend = FFMIN(end, rematrix_band_tab[bnd+1]);
-            for(i=rematrix_band_tab[bnd]; i<bndend; i++) {
-                tmp0 = ctx->transform_coeffs[1][i];
-                tmp1 = ctx->transform_coeffs[2][i];
-                ctx->transform_coeffs[1][i] = tmp0 + tmp1;
-                ctx->transform_coeffs[2][i] = tmp0 - tmp1;
+    for(bnd=0; bnd<nrematbnd; bnd++) {
+        if(rematflg[bnd]) {
+            bndend = FFMIN(end, ff_ac3_rematrix_band_tbl[bnd+1]);
+            for(i=ff_ac3_rematrix_band_tbl[bnd]; i<bndend; i++) {
+                tmp0 = transform_coeffs[1][i];
+                tmp1 = transform_coeffs[2][i];
+                transform_coeffs[1][i] = tmp0 + tmp1;
+                transform_coeffs[2][i] = tmp0 - tmp1;
             }
         }
     }
@@ -675,41 +645,41 @@
 /**
  * Perform the 256-point IMDCT
  */
-static void do_imdct_256(AC3DecodeContext *ctx, int chindex)
+void ff_ac3_do_imdct_256(float *tmp_output, float *transform_coeffs,
+        MDCTContext *imdct_256, float *tmp_imdct)
 {
     int i, k;
     DECLARE_ALIGNED_16(float, x[128]);
     FFTComplex z[2][64];
-    float *o_ptr = ctx->tmp_output;
 
     for(i=0; i<2; i++) {
         /* de-interleave coefficients */
         for(k=0; k<128; k++) {
-            x[k] = ctx->transform_coeffs[chindex][2*k+i];
+            x[k] = transform_coeffs[2*k+i];
         }
 
         /* run standard IMDCT */
-        ctx->imdct_256.fft.imdct_calc(&ctx->imdct_256, o_ptr, x, ctx->tmp_imdct);
+        imdct_256->fft.imdct_calc(imdct_256, tmp_output, x, tmp_imdct);
 
         /* reverse the post-rotation & reordering from standard IMDCT */
         for(k=0; k<32; k++) {
-            z[i][32+k].re = -o_ptr[128+2*k];
-            z[i][32+k].im = -o_ptr[2*k];
-            z[i][31-k].re =  o_ptr[2*k+1];
-            z[i][31-k].im =  o_ptr[128+2*k+1];
+            z[i][32+k].re = -tmp_output[128+2*k];
+            z[i][32+k].im = -tmp_output[2*k];
+            z[i][31-k].re =  tmp_output[2*k+1];
+            z[i][31-k].im =  tmp_output[128+2*k+1];
         }
     }
 
     /* apply AC-3 post-rotation & reordering */
     for(k=0; k<64; k++) {
-        o_ptr[    2*k  ] = -z[0][   k].im;
-        o_ptr[    2*k+1] =  z[0][63-k].re;
-        o_ptr[128+2*k  ] = -z[0][   k].re;
-        o_ptr[128+2*k+1] =  z[0][63-k].im;
-        o_ptr[256+2*k  ] = -z[1][   k].re;
-        o_ptr[256+2*k+1] =  z[1][63-k].im;
-        o_ptr[384+2*k  ] =  z[1][   k].im;
-        o_ptr[384+2*k+1] = -z[1][63-k].re;
+        tmp_output[    2*k  ] = -z[0][   k].im;
+        tmp_output[    2*k+1] =  z[0][63-k].re;
+        tmp_output[128+2*k  ] = -z[0][   k].re;
+        tmp_output[128+2*k+1] =  z[0][63-k].im;
+        tmp_output[256+2*k  ] = -z[1][   k].re;
+        tmp_output[256+2*k+1] =  z[1][63-k].im;
+        tmp_output[384+2*k  ] =  z[1][   k].im;
+        tmp_output[384+2*k+1] = -z[1][63-k].re;
     }
 }
 
@@ -730,7 +700,8 @@
 
     for (ch=1; ch<=nchans; ch++) {
         if (ctx->blksw[ch]) {
-            do_imdct_256(ctx, ch);
+            ff_ac3_do_imdct_256(ctx->tmp_output, ctx->transform_coeffs[ch],
+                    &ctx->imdct_256, ctx->tmp_imdct);
         } else {
             ctx->imdct_512.fft.imdct_calc(&ctx->imdct_512, ctx->tmp_output,
                                           ctx->transform_coeffs[ch],
@@ -750,7 +721,7 @@
 /**
  * Downmix the output to mono or stereo.
  */
-static void ac3_downmix(float samples[AC3_MAX_CHANNELS][256], int nfchans,
+void ff_ac3_downmix(float samples[AC3_MAX_CHANNELS][256], int nfchans,
                         int output_mode, float coef[AC3_MAX_CHANNELS][2])
 {
     int i, j;
@@ -804,7 +775,7 @@
     i = !(ctx->acmod);
     do {
         if(get_bits1(gb)) {
-            ctx->dynrng[i] = dynrng_tab[get_bits(gb, 8)];
+            ctx->dynrng[i] = ff_ac3_dynrng_tbl[get_bits(gb, 8)];
         } else if(blk == 0) {
             ctx->dynrng[i] = 1.0f;
         }
@@ -866,7 +837,7 @@
                             ctx->cplco[ch][bnd] = cplcomant / 16.0f;
                         else
                             ctx->cplco[ch][bnd] = (cplcomant + 16.0f) / 32.0f;
-                        ctx->cplco[ch][bnd] *= scale_factors[cplcoexp + mstrcplco];
+                        ctx->cplco[ch][bnd] *= ff_ac3_scale_factors[cplcoexp + mstrcplco];
                     }
                 }
             }
@@ -938,7 +909,7 @@
             else
                 ngrps = (ctx->endmant[ch] + grpsize - 4) / grpsize;
             ctx->dexps[ch][0] = get_bits(gb, 4) << !ch;
-            decode_exponents(gb, ctx->expstr[ch], ngrps, ctx->dexps[ch][0],
+            ff_ac3_decode_exponents(gb, ctx->expstr[ch], ngrps, ctx->dexps[ch][0],
                              &ctx->dexps[ch][ctx->startmant[ch]+!!ch]);
             if(ch != CPL_CH && ch != ctx->lfe_ch)
                 skip_bits(gb, 2); /* skip gainrng */
@@ -947,8 +918,8 @@
 
     /* bit allocation information */
     if (get_bits1(gb)) {
-        ctx->bit_alloc_params.sdecay = ff_sdecaytab[get_bits(gb, 2)] >> ctx->bit_alloc_params.halfratecod;
-        ctx->bit_alloc_params.fdecay = ff_fdecaytab[get_bits(gb, 2)] >> ctx->bit_alloc_params.halfratecod;
+        ctx->bit_alloc_params.sdecay = ff_sdecaytab[get_bits(gb, 2)];
+        ctx->bit_alloc_params.fdecay = ff_fdecaytab[get_bits(gb, 2)];
         ctx->bit_alloc_params.sgain  = ff_sgaintab[get_bits(gb, 2)];
         ctx->bit_alloc_params.dbknee = ff_dbkneetab[get_bits(gb, 2)];
         ctx->bit_alloc_params.floor  = ff_floortab[get_bits(gb, 3)];
@@ -1027,6 +998,7 @@
                                       ctx->startmant[ch], ctx->endmant[ch],
                                       ctx->snroffst[ch],
                                       ctx->bit_alloc_params.floor,
+                                      ff_ac3_baptab,
                                       ctx->bap[ch]);
         }
     }
@@ -1047,16 +1019,13 @@
 
     /* recover coefficients if rematrixing is in use */
     if(ctx->acmod == AC3_ACMOD_STEREO)
-        do_rematrixing(ctx);
+        ff_ac3_do_rematrixing(ctx->transform_coeffs,
+                FFMIN(ctx->endmant[1], ctx->endmant[2]),
+                ctx->nrematbnd, ctx->rematflg);
 
     /* apply scaling to coefficients (headroom, dialnorm, dynrng) */
     for(ch=1; ch<=ctx->nchans; ch++) {
         float gain = 2.0f * ctx->mul_bias;
-        if(ctx->acmod == AC3_ACMOD_DUALMONO) {
-            gain *= ctx->dialnorm[ch-1] * ctx->dynrng[ch-1];
-        } else {
-            gain *= ctx->dialnorm[0] * ctx->dynrng[0];
-        }
         for(i=0; i<ctx->endmant[ch]; i++) {
             ctx->transform_coeffs[ch][i] *= gain;
         }
@@ -1067,7 +1036,7 @@
     /* downmix output if needed */
     if(ctx->nchans != ctx->out_channels && !((ctx->output_mode & AC3_OUTPUT_LFEON) &&
             ctx->nfchans == ctx->out_channels)) {
-        ac3_downmix(ctx->output, ctx->nfchans, ctx->output_mode,
+        ff_ac3_downmix(ctx->output, ctx->nfchans, ctx->output_mode,
                     ctx->downmix_coeffs);
     }
 
@@ -1089,43 +1058,21 @@
 {
     AC3DecodeContext *ctx = (AC3DecodeContext *)avctx->priv_data;
     int16_t *out_samples = (int16_t *)data;
-    int i, blk, ch, err;
+    int i, blk, ch;
 
     /* initialize the GetBitContext with the start of valid AC-3 Frame */
     init_get_bits(&ctx->gb, buf, buf_size * 8);
 
     /* parse the syncinfo */
-    err = ac3_parse_header(ctx);
-    if(err) {
-        switch(err) {
-            case AC3_PARSE_ERROR_SYNC:
-                av_log(avctx, AV_LOG_ERROR, "frame sync error\n");
-                break;
-            case AC3_PARSE_ERROR_BSID:
-                av_log(avctx, AV_LOG_ERROR, "invalid bitstream id\n");
-                break;
-            case AC3_PARSE_ERROR_SAMPLE_RATE:
-                av_log(avctx, AV_LOG_ERROR, "invalid sample rate\n");
-                break;
-            case AC3_PARSE_ERROR_FRAME_SIZE:
-                av_log(avctx, AV_LOG_ERROR, "invalid frame size\n");
-                break;
-            default:
-                av_log(avctx, AV_LOG_ERROR, "invalid header\n");
-                break;
-        }
-        return -1;
+    if (ac3_parse_header(ctx)) {
+        av_log(avctx, AV_LOG_ERROR, "\n");
+        *data_size = 0;
+        return buf_size;
     }
 
     avctx->sample_rate = ctx->sampling_rate;
     avctx->bit_rate = ctx->bit_rate;
 
-    /* check that reported frame size fits in input buffer */
-    if(ctx->frame_size > buf_size) {
-        av_log(avctx, AV_LOG_ERROR, "incomplete frame\n");
-        return -1;
-    }
-
     /* channel config */
     ctx->out_channels = ctx->nchans;
     if (avctx->channels == 0) {
@@ -1152,11 +1099,89 @@
             av_log(avctx, AV_LOG_ERROR, "error parsing the audio block\n");
             *data_size = 0;
             return ctx->frame_size;
-        }
-        for (i = 0; i < 256; i++)
-            for (ch = 0; ch < ctx->out_channels; ch++)
-                *(out_samples++) = ctx->int_output[ch][i];
-    }
+       }
+       for (i = 0; i < 256; i++)
+           if (ctx->lfeon) {
+               switch (ctx->out_channels) {
+                   case 6:
+                       *(out_samples++) = ctx->int_output[0][i];   // FL
+                       *(out_samples++) = ctx->int_output[2][i];   // FR
+                       *(out_samples++) = ctx->int_output[1][i];   // FC
+                       *(out_samples++) = ctx->int_output[5][i];   // LFE
+                       *(out_samples++) = ctx->int_output[3][i];   // BL
+                       *(out_samples++) = ctx->int_output[4][i];   // BC
+                       break;
+                   case 5:
+                       if (ctx->acmod == 5) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                           *(out_samples++) = ctx->int_output[4][i];    // LFE
+                           *(out_samples++) = ctx->int_output[3][i];    // BC
+                       } else {                                    // acmod 6
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[4][i];    // LFE
+                           *(out_samples++) = ctx->int_output[2][i];    // BL
+                           *(out_samples++) = ctx->int_output[3][i];    // BR
+                       }
+                       break;
+                  case 4:
+                       if (ctx->acmod == 3) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                           *(out_samples++) = ctx->int_output[3][i];    // LFE
+                       } else {                                    // acmod 4
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[3][i];    // LFE
+                           *(out_samples++) = ctx->int_output[2][i];    // BC
+                       }
+                       break;
+                   default:
+                       for (ch = 0; ch < avctx->channels; ch++)
+                           *(out_samples++) = ctx->int_output[ch][i];
+               }
+           } else {
+               switch (ctx->out_channels) {
+                   case 5:
+                       *(out_samples++) = ctx->int_output[0][i];   // FL
+                       *(out_samples++) = ctx->int_output[2][i];   // FR
+                       *(out_samples++) = ctx->int_output[1][i];   // FC
+                       *(out_samples++) = ctx->int_output[3][i];   // BL
+                       *(out_samples++) = ctx->int_output[4][i];   // BC
+                       break;
+                   case 4:
+                       if (ctx->acmod == 5) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                            *(out_samples++) = ctx->int_output[3][i];    // BC
+                       } else {                                     // acmod 6
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[2][i];    // BL
+                           *(out_samples++) = ctx->int_output[3][i];    // BR
+                       }
+                       break;
+                   case 3:
+                       if (ctx->acmod == 3) {
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[2][i];    // FR
+                           *(out_samples++) = ctx->int_output[1][i];    // FC
+                       } else {                                    // acmod 4
+                           *(out_samples++) = ctx->int_output[0][i];    // FL
+                           *(out_samples++) = ctx->int_output[1][i];    // FR
+                           *(out_samples++) = ctx->int_output[2][i];    // BC
+                       }
+                       break;
+                   default:
+                       for (ch = 0; ch < ctx->out_channels; ch++)
+                           *(out_samples++) = ctx->int_output[ch][i];
+               }
+           }
+       }
     *data_size = NB_BLOCKS * 256 * avctx->channels * sizeof (int16_t);
     return ctx->frame_size;
 }


--- libavcodec/ac3dec.h	2007-09-26 18:28:13.000000000 +0200
+++ libavcodec/ac3dec.h	2007-09-26 18:06:07.000000000 +0200
@@ -0,0 +1,103 @@
+/*
+ * Common code between AC3 encoder and decoder
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file ac3.h
+ * Common code between AC3 encoder and decoder.
+ */
+
+#ifndef AC3DEC_H
+#define AC3DEC_H
+
+#include "ac3tab.h"
+#include "bitstream.h"
+#include "random.h"
+
+#define CPL_CH 0
+
+void ff_ac3_window_init(float *window);
+void ff_ac3_tables_init(void);
+
+/** tables for ungrouping mantissas */
+extern float ff_ac3_b1_mantissas[32][3];
+extern float ff_ac3_b2_mantissas[128][3];
+extern float ff_ac3_b3_mantissas[8];
+extern float ff_ac3_b4_mantissas[128][2];
+extern float ff_ac3_b5_mantissas[16];
+
+/** dynamic range table. converts codes to scale factors. */
+extern float ff_ac3_dynrng_tbl[256];
+
+/** dialogue normalization table */
+extern float ff_ac3_dialnorm_tbl[32];
+
+/**
+ * table for exponent to scale_factor mapping
+ * ff_ac3_scale_factors[i] = 2 ^ -i
+ */
+extern float ff_ac3_scale_factors[25];
+
+/** table for grouping exponents */
+extern uint8_t ff_ac3_exp_ungroup_tbl[128][3];
+
+/**
+ * Decode the grouped exponents according to exponent strategy.
+ * reference: Section 7.1.3 Exponent Decoding
+ */
+void ff_ac3_decode_exponents(GetBitContext *gb, int expstr, int ngrps,
+                             uint8_t absexp, int8_t *dexps);
+
+/**
+ * Grouped mantissas for 3-level 5-level and 11-level quantization
+ */
+typedef struct {
+    float b1_mant[3];
+    float b2_mant[3];
+    float b4_mant[2];
+    int b1ptr;
+    int b2ptr;
+    int b4ptr;
+} mant_groups;
+
+int ff_ac3_get_transform_coeffs_ch(mant_groups *m, GetBitContext *gb, uint8_t *exps,
+        uint8_t *bap, float *coeffs, int start, int end, AVRandomState *dith_state);
+
+void ff_ac3_do_rematrixing(float (*transform_coeffs)[256], int end, int nrematbnd, int *rematflg);
+
+void ff_ac3_do_imdct_256(float *tmp_output, float *transform_coeffs,
+        MDCTContext *imdct_256, float *tmp_imdct);
+
+void ff_ac3_downmix(float samples[AC3_MAX_CHANNELS][256], int nfchans,
+                        int output_mode, float coef[AC3_MAX_CHANNELS][2]);
+
+/** Adjustments in dB gain */
+#define LEVEL_PLUS_3DB          1.4142135623730950
+#define LEVEL_PLUS_1POINT5DB    1.1892071150027209
+#define LEVEL_MINUS_1POINT5DB   0.8408964152537145
+#define LEVEL_MINUS_3DB         0.7071067811865476
+#define LEVEL_MINUS_4POINT5DB   0.5946035575013605
+#define LEVEL_MINUS_6DB         0.5000000000000000
+#define LEVEL_MINUS_9DB         0.3535533905932738
+#define LEVEL_ZERO              0.0000000000000000
+#define LEVEL_ONE               1.0000000000000000
+
+
+#endif /* AC3DEC_H */

--- libavcodec/ac3tab.c    2007-09-14 00:02:17.000000000 +0200
+++ libavcodec/ac3tab.c       2007-09-14 00:03:58.000000000 +0200
@@ -25,6 +25,7 @@
  */

 #include "ac3tab.h"
+#include "ac3.h"

 /**
  * Possible frame sizes.
@@ -127,32 +128,32 @@
 };

 const uint8_t ff_ac3_latab[260]= {
-0x40,0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,
-0x36,0x35,0x34,0x34,0x33,0x32,0x31,0x30,0x2f,0x2f,
-0x2e,0x2d,0x2c,0x2c,0x2b,0x2a,0x29,0x29,0x28,0x27,
-0x26,0x26,0x25,0x24,0x24,0x23,0x23,0x22,0x21,0x21,
-0x20,0x20,0x1f,0x1e,0x1e,0x1d,0x1d,0x1c,0x1c,0x1b,
-0x1b,0x1a,0x1a,0x19,0x19,0x18,0x18,0x17,0x17,0x16,
-0x16,0x15,0x15,0x15,0x14,0x14,0x13,0x13,0x13,0x12,
-0x12,0x12,0x11,0x11,0x11,0x10,0x10,0x10,0x0f,0x0f,
-0x0f,0x0e,0x0e,0x0e,0x0d,0x0d,0x0d,0x0d,0x0c,0x0c,
-0x0c,0x0c,0x0b,0x0b,0x0b,0x0b,0x0a,0x0a,0x0a,0x0a,
-0x0a,0x09,0x09,0x09,0x09,0x09,0x08,0x08,0x08,0x08,
-0x08,0x08,0x07,0x07,0x07,0x07,0x07,0x07,0x06,0x06,
-0x06,0x06,0x06,0x06,0x06,0x06,0x05,0x05,0x05,0x05,
-0x05,0x05,0x05,0x05,0x04,0x04,0x04,0x04,0x04,0x04,
-0x04,0x04,0x04,0x04,0x04,0x03,0x03,0x03,0x03,0x03,
-0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x02,
-0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
-0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x01,
-0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x0040,0x003f,0x003e,0x003d,0x003c,0x003b,0x003a,0x0039,0x0038,0x0037,
+0x0036,0x0035,0x0034,0x0034,0x0033,0x0032,0x0031,0x0030,0x002f,0x002f,
+0x002e,0x002d,0x002c,0x002c,0x002b,0x002a,0x0029,0x0029,0x0028,0x0027,
+0x0026,0x0026,0x0025,0x0024,0x0024,0x0023,0x0023,0x0022,0x0021,0x0021,
+0x0020,0x0020,0x001f,0x001e,0x001e,0x001d,0x001d,0x001c,0x001c,0x001b,
+0x001b,0x001a,0x001a,0x0019,0x0019,0x0018,0x0018,0x0017,0x0017,0x0016,
+0x0016,0x0015,0x0015,0x0015,0x0014,0x0014,0x0013,0x0013,0x0013,0x0012,
+0x0012,0x0012,0x0011,0x0011,0x0011,0x0010,0x0010,0x0010,0x000f,0x000f,
+0x000f,0x000e,0x000e,0x000e,0x000d,0x000d,0x000d,0x000d,0x000c,0x000c,
+0x000c,0x000c,0x000b,0x000b,0x000b,0x000b,0x000a,0x000a,0x000a,0x000a,
+0x000a,0x0009,0x0009,0x0009,0x0009,0x0009,0x0008,0x0008,0x0008,0x0008,
+0x0008,0x0008,0x0007,0x0007,0x0007,0x0007,0x0007,0x0007,0x0006,0x0006,
+0x0006,0x0006,0x0006,0x0006,0x0006,0x0006,0x0005,0x0005,0x0005,0x0005,
+0x0005,0x0005,0x0005,0x0005,0x0004,0x0004,0x0004,0x0004,0x0004,0x0004,
+0x0004,0x0004,0x0004,0x0004,0x0004,0x0003,0x0003,0x0003,0x0003,0x0003,
+0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0003,0x0002,
+0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,
+0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0002,0x0001,0x0001,
+0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,
+0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,
+0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
 };

 const uint16_t ff_ac3_hth[50][3]= {
@@ -208,6 +209,16 @@
 { 0x0840,0x0840,0x04e0 },
 };

+const uint8_t ff_ac3_hebaptab[64] = {
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 8,
+    8, 8, 9, 9, 9, 10, 10, 10, 10, 11,
+    11, 11, 11, 12, 12, 12, 12, 13, 13, 13,
+    13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
+    16, 16, 16, 17, 17, 17, 17, 18, 18, 18,
+    18, 18, 18, 18, 18, 19, 19, 19, 19, 19,
+    19, 19, 19, 19,
+};
+
 const uint8_t ff_ac3_baptab[64]= {
     0, 1, 1, 1, 1, 1, 2, 2, 3, 3,
     3, 4, 4, 5, 5, 6, 6, 6, 6, 7,
@@ -218,6 +229,11 @@
     15, 15, 15, 15,
 };

+const uint8_t ff_bits_vs_hebap[20] = {
+    0,  2,  3,  4,  5,  7,  8,  9,  3,  4,
+    5,  6,  7,  8,  9, 10, 11, 12, 14, 16,
+};
+
 const uint8_t ff_sdecaytab[4]={
     0x0f, 0x11, 0x13, 0x15,
 };
@@ -247,3 +263,1145 @@
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3,
     3, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 24, 24, 24, 24, 24
 };
+
+/**
+ * Quantization table: levels for symmetric. bits for asymmetric.
+ * reference: Table 7.18 Mapping of bap to Quantizer
+ */
+const uint8_t ff_qntztab[16] = {
+    0, 3, 5, 7, 11, 15,
+    5, 6, 7, 8, 9, 10, 11, 12, 14, 16
+};
+
+const uint8_t ff_eac3_blocks[4] = {
+    1, 2, 3, 6
+};
+
+const uint8_t ff_nfchans_tbl[8] = { 2, 1, 2, 3, 3, 4, 4, 5 };
+
+/**
+ * Table E3.6
+ * Large mantissa inverse quantization (remapping) constants
+ * ff_eac3_gaq_remap[hebap+8][x<0,x>=0][Gk=1,2,4][a,b]
+ */
+const int16_t ff_eac3_gaq_remap[12][2][3][2] = {
+{{{   4681,       0}, { -10923,   16384}, {  -4681,    8192}},
+ {{   4681,       0}, { -10923,   -5461}, {  -4681,   -1170}}},
+{{{   2185,       0}, { -14043,   16384}, {  -6554,    8192}},
+ {{   2185,       0}, { -14043,  -11703}, {  -6554,   -4915}}},
+{{{   1057,       0}, { -15292,   16384}, {  -7399,    8192}},
+ {{   1057,       0}, { -15292,  -14199}, {  -7399,   -6606}}},
+{{{    520,       0}, { -15855,   16384}, {  -7802,    8192}},
+ {{    520,       0}, { -15855,  -15327}, {  -7802,   -7412}}},
+{{{    258,       0}, { -16124,   16384}, {  -7998,    8192}},
+ {{    258,       0}, { -16124,  -15864}, {  -7998,   -7805}}},
+{{{    129,       0}, { -16255,   16384}, {  -8096,    8192}},
+ {{    129,       0}, { -16255,  -16126}, {  -8096,   -7999}}},
+{{{     64,       0}, { -16320,   16384}, {  -8144,    8192}},
+ {{     64,       0}, { -16320,  -16255}, {  -8144,   -8096}}},
+{{{     32,       0}, { -16352,   16384}, {  -8168,    8192}},
+ {{     32,       0}, { -16352,  -16320}, {  -8168,   -8144}}},
+{{{     16,       0}, { -16368,   16384}, {  -8180,    8192}},
+ {{     16,       0}, { -16368,  -16352}, {  -8180,   -8168}}},
+{{{      8,       0}, {      0,       0}, {      0,       0}},
+ {{      8,       0}, {      0,       0}, {      0,       0}}},
+{{{      2,       0}, {      0,       0}, {      0,       0}},
+ {{      2,       0}, {      0,       0}, {      0,       0}}},
+{{{      0,       0}, {      0,       0}, {      0,       0}},
+ {{      0,       0}, {      0,       0}, {      0,       0}}},
+};
+
+/**
+ * Map GAQ mode and gaqgain to Gk
+ * Gk = 1 << ff_gaq_gk[GAQ Mode][gaqgain]
+ */
+const uint8_t ff_gaq_gk[4][3]={
+    {0, 0, 0},
+    {0, 1, 0},
+    {0, 2, 0},
+    {0, 1, 2}
+};
+
+const int16_t ff_vq_hebap1[4][6] = {
+{   7167,    4739,    1106,    4269,   10412,    4820},
+{  -5702,   -3187,  -14483,   -1392,   -2027,     849},
+{    633,    6199,    7009,  -12779,   -2306,   -2636},
+{  -1468,   -7031,    7592,   10617,   -5946,   -3062},
+};
+const int16_t ff_vq_hebap2[8][6] = {
+{ -12073,     608,   -7019,     590,    4000,     869},
+{   6692,   15689,   -6178,   -9239,     -74,     133},
+{   1855,    -989,   20596,   -2920,   -4475,     225},
+{  -1194,   -3901,    -821,   -6566,    -875,  -20298},
+{  -2762,   -3181,   -4094,   -5623,  -16945,    9765},
+{   1547,    6839,    1980,   20233,   -1071,   -4986},
+{   6221,  -17915,   -5516,    6266,     358,    1162},
+{   3753,   -1066,    4283,   -3227,   15928,   10186},
+};
+const int16_t ff_vq_hebap3[16][6] = {
+{ -10028,   20779,   10982,   -4560,     798,     -68},
+{  11050,   20490,   -6617,   -5342,   -1797,   -1631},
+{   3977,    -542,    7118,   -1166,   18844,   14678},
+{  -4320,     -96,   -7295,    -492,  -22050,   -4277},
+{   2692,    5856,    5530,   21862,   -7212,   -5325},
+{   -135,  -23391,     962,    8115,    -644,     382},
+{  -1563,    3400,   -3299,    4693,   -6892,   22398},
+{   3535,    3030,    7296,    6214,   20476,  -12099},
+{     57,   -6823,    1848,  -22349,   -5919,    6823},
+{   -821,   -3655,    -387,   -6253,   -1735,  -22373},
+{  -6046,    1586,  -18890,  -14392,    9214,     705},
+{  -5716,     264,  -17964,   14618,    7921,    -337},
+{   -110,     108,       8,      74,     -89,     -50},
+{   6612,   -1517,   21687,   -1658,   -7949,    -246},
+{  21667,   -6335,   -8290,    -101,   -1349,     -22},
+{ -22003,   -6476,    7974,     648,    2054,    -331},
+};
+const int16_t ff_vq_hebap4[32][6] = {
+{   6636,   -4593,   14173,  -17297,  -16523,     864},
+{   3658,   22540,     104,   -1763,     -84,       6},
+{  21580,  -17815,   -7282,   -1575,   -2078,    -320},
+{  -2233,   10017,   -2728,   14938,  -13640,  -17659},
+{  -1564,  -17738,  -19161,   13735,    2757,    2951},
+{   4520,    5510,    7393,   10799,   19231,  -13770},
+{    399,    2976,   -1099,    5013,   -1159,   22095},
+{   3624,   -2359,    4680,   -2238,   22702,    3765},
+{  -4201,   -8285,   -6810,  -12390,  -18414,   15382},
+{  -5198,   -6869,  -10047,   -8364,  -16022,  -20562},
+{   -142,  -22671,    -368,    4391,    -464,     -13},
+{    814,   -1118,   -1089,  -22019,      74,    1553},
+{  -1618,   19222,  -17642,  -13490,     842,   -2309},
+{   4689,   16490,   20813,  -15387,   -4164,   -3968},
+{  -3308,   11214,  -13542,   13599,  -19473,   13770},
+{   1817,     854,   21225,    -966,   -1643,    -268},
+{  -2587,    -107,  -20154,     376,    1174,    -304},
+{  -2919,     453,   -5390,     750,  -22034,    -978},
+{ -19012,   16839,   10000,   -3580,    2211,    1459},
+{   1363,   -2658,     -33,   -4067,    1165,  -21985},
+{  -8592,   -2760,  -17520,  -15985,   14897,    1323},
+{    652,   -9331,    3253,  -14622,   12181,   19692},
+{  -6361,    5773,  -15395,   17291,   16590,   -2922},
+{   -661,    -601,    1609,   22610,     992,   -1045},
+{   4961,    9107,   11225,    7829,   16320,   18627},
+{ -21872,   -1433,     138,    1470,   -1891,    -196},
+{ -19499,  -18203,   11056,    -516,    2543,   -2249},
+{  -1196,  -17574,   20150,   11462,    -401,    2619},
+{   4638,   -8154,   11891,  -15759,   17615,  -14955},
+{    -83,     278,     323,      55,    -154,     232},
+{   7788,    1462,   18395,   15296,  -15763,   -1131},
+};
+const int16_t ff_vq_hebap5[128][6] = {
+{  -3394,  -19730,    2963,    9590,    4660,   19673},
+{ -15665,   -6405,   17671,    3860,   -8232,  -19429},
+{   4467,     412,  -17873,   -8037,     691,  -17307},
+{   3580,    2363,    6886,    3763,    6379,  -20522},
+{ -17230,  -14133,   -1396,  -23939,    8373,  -12537},
+{  -8073,  -21469,  -15638,    3214,    8105,   -5965},
+{   4343,    5169,    2683,  -16822,   -5146,  -16558},
+{   6348,  -10668,   12995,  -25500,  -22090,    4091},
+{  -2880,   -8366,   -5968,  -17158,   -2638,   23132},
+{  -5095,  -14281,  -22371,   21741,    3689,    2961},
+{  -2443,  -17739,   25155,    2707,    1594,       7},
+{ -18379,    9010,    4270,     731,    -426,    -640},
+{ -23695,   24732,    5642,     612,    -308,    -964},
+{   -767,    1268,     225,    1635,     173,     916},
+{   5455,    6493,    4902,   10560,   23041,  -17140},
+{  17219,  -21054,  -18716,    4936,   -3420,    3357},
+{  -1390,   15488,  -21946,  -14611,    1339,     542},
+{  -6866,   -2254,  -12070,   -3075,  -19981,  -20622},
+{  -1803,   11775,    1343,    8917,     693,   24497},
+{ -21610,    9462,    4681,    9254,   -7815,   15904},
+{  -5559,   -3018,   -9169,   -1347,  -22547,   12868},
+{   -366,    5076,   -1727,   20427,    -283,   -2923},
+{  -1886,   -6313,    -939,   -2081,   -1399,    3513},
+{  -3161,    -537,   -5075,   11268,   19396,     989},
+{   2345,    4153,    5769,   -4273,     233,    -399},
+{ -21894,   -1138,  -16474,    5902,    5488,   -3211},
+{  10007,  -12530,   18829,   20932,   -1158,    1790},
+{  -1165,    5014,   -1199,    6415,   -8418,  -21038},
+{   1892,   -3534,    3815,   -5846,   16427,   20288},
+{  -2664,  -11627,   -4147,  -18311,  -22710,   14848},
+{  17256,   10419,    7764,   12040,   18956,    2525},
+{ -21419,  -18685,  -10897,    4368,   -7051,    4539},
+{  -1574,    2050,    5760,   24756,   15983,   17678},
+{   -538,  -22867,   11067,   10301,     385,     528},
+{  -8465,   -3025,  -16357,  -23237,   16491,    3654},
+{   5840,     575,   11890,    1947,   25157,    6653},
+{   6625,   -3516,   -1964,    3850,    -390,    -116},
+{  18005,   20900,   14323,   -7621,  -10922,   11802},
+{  -4857,   -2932,  -13334,   -7815,   21622,    2267},
+{   -579,   -9431,    -748,  -21321,   12367,    8265},
+{  -8317,    1375,  -17847,    2921,    9062,   22046},
+{  18398,    8635,   -1503,   -2418,  -18295,  -14734},
+{  -2987,   15129,   -3331,   22300,   13878,  -13639},
+{   5874,  -19026,   15587,   11350,  -20738,    1971},
+{   1581,   -6955,  -21440,    2455,      65,     414},
+{    515,   -4468,    -665,   -4672,     125,  -19222},
+{  21495,  -20301,   -1872,   -1926,    -211,   -1022},
+{   5189,  -12250,   -1775,  -23550,   -4546,    5813},
+{    321,   -6331,   14646,    6975,   -1773,     867},
+{ -13814,    3180,    7927,     444,   19552,    3146},
+{  -6660,   12252,   -1972,   17408,  -24280,  -12956},
+{   -745,   14356,   -1107,   23742,   -9631,  -18344},
+{  18284,   -7909,   -7531,   19118,    7721,  -12659},
+{   1926,   15101,  -12848,    2153,   21631,    1864},
+{  -2130,   23416,   17056,  -15597,   -1544,      87},
+{   8314,  -11824,   14581,  -20591,    7891,   -2099},
+{  19600,   22814,  -17304,   -2040,     285,   -3863},
+{  -8214,  -18322,   10724,  -13744,  -13469,   -1666},
+{  14351,    4880,  -20034,     964,   -4221,    -180},
+{ -24598,  -16635,   19724,    5925,    4777,    4414},
+{  -2495,   23493,  -16141,    2918,   -1038,   -2010},
+{  18974,   -2540,   13343,    1405,   -6194,   -1136},
+{   2489,   13670,   22638,   -7311,    -129,   -2792},
+{ -13962,   16775,   23012,     728,    3397,     162},
+{   3038,     993,    8774,  -21969,   -6609,     910},
+{ -12444,  -22386,   -2626,   -5295,   19520,    9872},
+{  -1911,  -18274,  -18506,  -14962,    4760,    7119},
+{   8298,   -2978,   25886,    7660,   -7897,    1020},
+{   6132,   15127,   18757,  -24370,   -6529,   -6627},
+{   7924,   12125,   -9459,  -23962,    5502,     937},
+{ -17056,   -5373,    2522,     327,    1129,    -390},
+{  15774,   19955,  -10380,   11172,   -3107,   14853},
+{ -11904,   -8091,  -17928,  -22287,  -17237,   -6803},
+{ -12862,   -2172,   -6509,    5927,   12458,  -22355},
+{   -497,     322,    1038,   -6643,   -5404,   20311},
+{   1083,  -22984,   -8494,   12130,    -762,    2623},
+{   5067,   19712,   -1901,     -30,    -325,      85},
+{    987,   -5830,    4212,   -9030,    9121,  -25038},
+{  -7868,    7284,  -12292,   12914,  -21592,   20941},
+{  -1630,   -7694,   -2187,   -8525,   -5604,  -25196},
+{  -6668,     388,  -22535,    1526,    9082,     193},
+{  -7867,  -22308,    5163,     362,     944,    -259},
+{   3824,  -11850,    7591,  -23176,   25342,   23771},
+{ -10504,    4123,  -21111,   21173,   22439,    -838},
+{  -4723,   21795,    6184,    -122,    1642,    -717},
+{  24504,   19887,   -2043,     986,       7,     -55},
+{ -27313,    -135,    2437,     259,      89,     307},
+{  24446,   -3873,   -5391,    -820,   -2387,     361},
+{   5529,    5784,   18682,     242,  -21896,   -4003},
+{  22304,    4483,     722,  -12242,    7570,   15448},
+{   8673,    3009,   20437,   21108,  -21100,   -3080},
+{  -1132,    2705,   -1825,    5420,    -785,   18532},
+{  16932,  -13517,  -16509,  -14858,  -20327,  -14221},
+{   2219,    1380,   21474,   -1128,     327,      83},
+{  -2177,   21517,   -3856,  -14180,    -204,   -2191},
+{    953,   -9426,   15874,  -10710,   -3231,   21030},
+{   -421,   -1377,     640,   -8239,  -20976,    2174},
+{   4309,   18514,   -9100,  -18319,  -15518,    3704},
+{  -5943,     449,   -8387,    1075,  -22210,   -4992},
+{   2953,   12788,   18285,    1430,   14937,   21731},
+{  -2913,     401,   -4739,  -20105,    1699,   -1147},
+{   3449,    5241,    8853,   22134,   -7547,    1451},
+{  -2154,    8584,   18120,  -15614,   19319,   -5991},
+{   3501,    2841,    5897,    6397,    8630,   23018},
+{   2467,    2956,     379,    5703,  -22047,   -2189},
+{ -16963,    -594,   18822,   -5295,    1640,     774},
+{   2896,   -1424,    3586,   -2292,   19910,   -1822},
+{ -18575,   21219,  -14001,  -12573,   16466,     635},
+{  -1998,  -19314,  -16527,   12208,  -16576,   -7854},
+{  -9674,    1012,  -21645,    2883,  -12712,    2321},
+{  -1005,     471,   -3629,    8045,  -11087,   25533},
+{   4141,  -21472,   -2673,     756,    -663,    -523},
+{   6490,    8531,   19289,   18949,    6092,   -9347},
+{  16965,   24599,   14024,   10072,    -536,  -10438},
+{  -8147,    2145,  -23028,  -17073,    5451,   -4401},
+{ -14873,   20520,  -18303,   -9717,  -11885,  -17831},
+{  -2290,  -14120,    2070,   22467,    1671,     725},
+{  -8538,   14629,    3521,  -20577,    6673,    8200},
+{  20248,    4410,   -1366,    -585,    1229,   -2449},
+{   7467,   -7148,   13667,   -8246,   22392,  -17320},
+{  -1932,    3875,   -9064,   -3812,     958,     265},
+{  -4399,    2959,  -15911,   19598,    4954,   -1105},
+{  18009,   -9923,  -18137,   -3862,   11178,    5821},
+{ -14596,   -1227,    9660,   21619,   11228,  -11721},
+{   -721,   -1700,     109,   -2142,      61,   -6772},
+{ -24619,  -22520,    5608,   -1957,   -1761,   -1012},
+{ -23728,   -4451,   -2688,  -14679,   -4266,    9919},
+{   8495,    -894,   20438,  -13820,  -17267,     139},
+};
+const int16_t ff_vq_hebap6[256][6] = {
+{  10154,    7365,   16861,   18681,  -22893,   -3636},
+{  -2619,   -3788,   -5529,   -5192,   -9009,  -20298},
+{  -5583,  -22800,   21297,    7012,     745,     720},
+{    428,   -1459,     109,   -3082,     361,   -8403},
+{   8161,   22401,     241,    1755,    -874,   -2824},
+{   1140,   12643,    2306,   22263,  -25146,  -17557},
+{  -2609,    3379,   10337,  -19730,  -15468,  -23944},
+{  -4040,  -12796,  -25772,   13096,    3905,    1315},
+{   4624,  -23799,   13608,   25317,   -1175,    2173},
+{    -97,   13747,   -5122,   23255,    4214,  -22145},
+{   6878,    -322,   18264,    -854,  -11916,    -733},
+{  17280,  -12669,   -9693,   23563,  -16240,   -1309},
+{   5802,   -4968,   19526,  -21194,  -24622,    -183},
+{   5851,  -16137,   15229,   -9496,   -1538,     377},
+{  14096,   25057,   13419,    8290,   23320,   16818},
+{  -7261,     118,  -15867,   19097,    9781,    -277},
+{  -4288,   21589,  -13288,  -16259,   16633,   -4862},
+{   4909,  -19217,   23411,   14705,    -722,     125},
+{  19462,   -4732,   -1928,  -11527,   20770,    5425},
+{ -27562,   -2881,   -4331,     384,   -2103,    1367},
+{   -266,   -9175,    5441,   26333,   -1924,    4221},
+{  -2970,  -20170,  -21816,    5450,   -7426,    5344},
+{   -221,   -6696,     603,   -9140,    1308,  -27506},
+{   9621,   -8380,   -1967,    9403,   -1651,   22817},
+{   7566,   -5250,   -4165,    1385,    -990,     560},
+{  -1262,   24738,  -19057,   10741,    7585,   -7098},
+{    451,   20130,   -9949,   -6015,   -2188,   -1458},
+{  22249,    9380,    9096,   10959,   -2365,   -3724},
+{  18668,    -650,   -1234,   11092,    7678,    5969},
+{  19207,   -1485,   -1076,    -731,    -684,      43},
+{  -4973,   13430,   20139,      60,     476,    -935},
+{ -20029,    8710,    2499,    1016,   -1158,     335},
+{ -26413,   18598,   -2201,    -669,    3409,     793},
+{  -4726,    8875,  -24607,   -9646,    3643,    -283},
+{  13303,  -21404,   -3691,   -1184,   -1970,    1612},
+{    173,      60,     919,    1229,    6942,    -665},
+{  16377,   16991,    5341,  -14015,   -2304,  -20390},
+{  25334,  -10609,   11947,   -7653,   -6363,   14058},
+{  23929,  -13259,   -7226,    -937,     234,    -187},
+{   6311,   -1877,   12506,   -1879,   18751,  -23341},
+{    621,    6445,    3354,  -24274,    8406,    5315},
+{  -3297,   -5034,   -4704,   -5080,  -25730,    5347},
+{  -1275,  -13295,    -965,  -23318,    1214,   26259},
+{  -6252,   10035,  -20105,   15301,  -16073,    5136},
+{   9562,   -3911,  -19510,    4745,   22270,   -4171},
+{   7978,  -19600,   14024,   -5745,  -20855,    8939},
+{      7,   -4039,     991,   -6065,      52,  -19423},
+{   3485,    2969,    7732,    7786,   25312,    6206},
+{   -959,  -12812,   -1840,  -22743,    7324,   10830},
+{  -4686,    1678,  -10172,   -5205,    4294,   -1271},
+{   3889,    1302,    7450,     638,   20374,   -3133},
+{ -12496,   -9123,   18463,  -12343,   -7238,   18552},
+{  -6185,    8649,   -6903,    -895,   17109,   16604},
+{  -9896,   28579,    2845,    1640,    2925,    -298},
+{  14968,  -25988,   14878,  -24012,    1815,   -6474},
+{  26107,    5166,   21225,   15873,   21617,   14825},
+{ -21684,   16438,   20504,  -14346,   -7114,   -4162},
+{  28647,      90,   -1572,     789,    -902,     -75},
+{  -1479,    2471,   -4061,    3612,   -2240,   10914},
+{   8616,   17491,   17255,  -17456,   17022,  -16357},
+{ -20722,  -18597,   25274,   17720,   -3573,    1695},
+{   -997,    6129,   -6303,   11250,  -11359,  -19739},
+{    -74,   -4001,   -1584,   13384,     162,    -144},
+{   -529,   21068,    7923,  -11396,     422,     -26},
+{   7102,  -13531,  -20055,    2629,    -178,    -429},
+{   9201,    1368,  -22238,    2623,  -20499,   24889},
+{   -432,    6675,    -266,    8723,      80,   28024},
+{  19493,   -3108,   -9261,    1910,  -21777,    5345},
+{  14079,  -11489,   12604,    6079,   19877,    1315},
+{  10947,    9837,  -18612,   15742,    4792,     605},
+{  -1777,    3758,   -4087,   21696,    6024,    -576},
+{   3567,   -3578,   16379,    2680,   -1752,     716},
+{  -5049,   -1399,   -4550,    -652,  -17721,   -3366},
+{  -3635,   -4372,   -6522,  -22152,    7382,    1458},
+{  12242,   19190,    5646,   -7815,  -20289,   21344},
+{  -7508,   19952,   23542,   -9753,    5669,   -1990},
+{  -2275,   15438,   10907,  -17879,    6497,   13582},
+{ -15894,  -15646,   -4716,    6019,   24250,   -6179},
+{  -2049,   -6856,   -1208,     918,   17735,     -69},
+{  -3721,    9099,  -16065,  -23621,    5981,   -2344},
+{   7862,   -8918,   24033,   25508,  -11033,    -741},
+{ -12588,   19468,   14649,   15451,  -21226,    1171},
+{   2102,    1147,    2789,    4096,    2179,    8750},
+{ -18214,  -17758,  -10366,   -5203,   -1066,   -3541},
+{  -2819,  -19958,  -11921,    6032,    8315,   10374},
+{  -9078,   -2100,   19431,     -17,     732,    -689},
+{ -14512,  -19224,   -7095,   18727,    1870,   22906},
+{   3912,     659,   25597,   -4006,    9619,     877},
+{   2616,   22695,   -5770,   17920,    3812,   20220},
+{   2561,   26847,   -5245,  -10908,    2256,    -517},
+{  -4974,     198,  -21983,   -3608,   22174,  -18924},
+{  21308,   -1211,   19144,   16691,   -1588,   11390},
+{  -1790,    3959,   -3488,    7003,   -7107,   20877},
+{  -6108,  -17955,  -18722,   24763,   16508,    3211},
+{  20462,  -24987,  -20361,    4484,   -5111,    -478},
+{  -6378,   -1998,  -10229,    -561,  -22039,  -22339},
+{   3047,  -18850,    7586,   14743,  -19862,    6351},
+{  -5047,    1405,   -9672,    1055,  -21881,   11170},
+{   3481,   -9699,    6526,  -16655,   22813,   21907},
+{ -18570,   17501,   14664,    1291,    5026,   19676},
+{  16134,  -19810,  -16956,  -17939,  -16933,    5800},
+{  -8224,    4908,    8935,    2272,   -1140,  -23217},
+{   1572,    2753,   -1598,    2143,   -3346,  -21926},
+{  -9832,   -1060,  -27818,    1214,    7289,     150},
+{     98,    1538,     535,   17429,  -23198,    -901},
+{  21340,  -20146,    3297,   -1744,   -8207,  -21462},
+{  -4166,   -4633,  -17902,    5478,    1285,     136},
+{  18713,   21003,   24818,   11421,    1282,   -4618},
+{  -3535,    7636,    -265,    2141,    -829,   -2035},
+{  -3184,   19713,    2775,      -2,    1090,     104},
+{  -6771,  -20185,    2938,   -2125,     -36,    1268},
+{   9560,    9430,    9586,   22100,   13827,    6296},
+{   -535,  -20018,    4276,   -1868,    -448,  -17183},
+{ -24352,   14244,  -13647,  -21040,    2271,   11555},
+{  -2646,   15437,   -4589,   18638,   -4299,    -622},
+{ -20064,    4169,   18115,   -1404,   13722,   -1825},
+{ -16359,    9080,     744,   22021,     125,   10794},
+{   9644,  -14607,  -18479,  -14714,   11174,  -20754},
+{   -326,  -23762,    6144,    7909,     602,    1540},
+{  -6650,    6634,  -12683,   21396,   20785,   -6839},
+{   4252,  -21043,    5628,   18687,   23860,    8328},
+{  17986,    5704,   -5245,  -18093,    -555,    3219},
+{   6091,   14232,   -5117,  -17456,  -19452,  -11649},
+{ -21586,   11302,   15434,   25590,    6777,  -26683},
+{  21355,   -8244,    5877,   -3540,    6079,   -2567},
+{   2603,   -2455,    5421,  -12286,  -19100,    5574},
+{  -1721,  -26393,  -23664,   22904,    -349,    3787},
+{   2189,   -1203,    5340,    3249,  -22617,     104},
+{  -1664,  -11020,   -2857,  -20723,  -24049,   19900},
+{  22873,   -7345,  -18481,  -14616,   -8400,  -12965},
+{   3777,    3958,    8239,   20494,   -6991,   -1201},
+{   -160,   -1613,    -793,   -8681,     573,     776},
+{   4297,   -3786,   20373,    6082,   -5321,  -18400},
+{  18745,    2463,   12546,   -7749,   -7734,   -2183},
+{  11074,   -4720,   22119,    1825,  -24351,    4080},
+{   1503,  -19178,   -1569,      13,    -313,     375},
+{    318,    -575,    2544,     178,     102,      40},
+{ -15996,  -26897,    5008,    3320,     686,    1159},
+{  25755,   26886,     574,   -5930,   -3916,    1407},
+{  -9148,   -7665,   -2875,   -8384,  -18663,   26400},
+{  -7445,  -18040,  -18396,    8802,   -2252,  -21886},
+{   7851,   11773,   27485,  -12847,   -1410,   19590},
+{   2240,    5947,   11247,   15980,   -6499,   24280},
+{  21673,  -18515,    9771,    6550,   -2730,     334},
+{  -4149,    1576,  -11010,      89,  -24429,   -5710},
+{   7720,    1478,   21412,  -25025,   -8385,       9},
+{  -2448,   10218,  -12756,  -16079,    1161,  -21284},
+{  -8757,  -14429,  -22918,  -14812,    2629,   13844},
+{  -7252,    2843,   -9639,    2882,  -14625,   24497},
+{   -674,   -6530,     414,  -23333,  -21343,     454},
+{   2104,   -6312,   10887,   18087,   -1199,     175},
+{   -493,    -562,   -2739,     118,   -1074,      93},
+{ -10011,   -4075,  -28071,   22180,   15077,    -636},
+{  -4637,  -16408,   -9003,  -20418,  -11608,  -20932},
+{   4815,   15892,   24238,  -13634,   -3074,   -1059},
+{  -6724,    4610,  -18772,  -15283,  -16685,   23988},
+{  15349,    -674,   -3682,   21679,    4475,  -12088},
+{   4756,    2593,    5354,    6001,   15063,   26490},
+{ -23815,  -17251,    6944,     378,     694,     670},
+{  23392,   -8839,  -14713,    7544,    -876,   11088},
+{   3640,    3336,   22593,   -3495,   -2328,    -113},
+{    284,    6914,    3097,   10171,    6638,  -18621},
+{   2472,    5976,   11054,  -11936,    -603,    -663},
+{  16175,   16441,   13164,   -4043,    4667,    7431},
+{  19338,   15534,   -6533,    1681,   -4857,   17048},
+{  17027,     532,  -19064,   -1441,   -5130,    1085},
+{ -12617,  -17609,    2062,  -25332,   19009,  -16121},
+{  10056,  -21000,  -13634,   -2949,   15367,   19934},
+{   -648,   -1605,   10046,   -1592,   13296,   19808},
+{  -1054,   10744,     538,   24938,    9630,   -9052},
+{ -10099,    3042,  -25076,  -24052,   13971,     100},
+{   6547,    6907,    7031,   10348,   23775,  -17886},
+{ -22793,   -1984,   -1393,   -3330,    9267,   14317},
+{ -14346,   -3967,    3042,   16254,  -17303,    9646},
+{ -21393,   23628,   16773,     716,    2663,     114},
+{ -19016,   -3038,    1574,    -245,    1463,    -793},
+{  22410,   23441,  -14637,    -530,   17310,   13617},
+{ -11582,    7935,  -13954,   23465,  -24628,   26550},
+{  -1045,    3679,   -2218,   10572,   20999,   -3702},
+{ -15513,     197,   16718,  -24603,    4945,       5},
+{  10781,    4335,   26790,   -9059,  -16152,   -2840},
+{  16075,  -24100,   -3933,   -6833,   12645,   -7029},
+{   2096,  -25572,   -8370,    6814,      11,    1178},
+{ -11848,    -583,   -8889,  -20543,  -10471,    -380},
+{  -2487,   24777,  -21639,  -19341,    1660,    -732},
+{   2313,   13679,    4085,   24549,   24691,  -21179},
+{  -2366,    -504,   -4130,  -10570,   23668,    1961},
+{  20379,   17809,   -9506,    3733,  -18954,   -6292},
+{  -3856,   16802,    -929,  -20310,  -17739,    6797},
+{  12431,    6078,  -11272,  -14450,    6913,   23476},
+{   7636,   -1655,   23017,   10719,   -8292,     838},
+{  -8559,   -1235,  -18096,    3897,   16093,    1490},
+{  -3586,    8276,   15165,   -3791,  -21149,    1741},
+{  -4497,   21739,    2366,    -278,   -4792,   15549},
+{ -23122,  -13708,    7668,   16232,   24120,   15025},
+{ -20043,   12821,  -20160,   16691,  -11655,  -16081},
+{ -12601,   20239,    3496,   -2549,   -6745,  -11850},
+{   4441,    7812,   20783,   17080,   11523,   -9643},
+{  24766,    8494,  -23298,   -3262,   11101,   -7120},
+{ -10107,   -7623,  -22152,  -18303,   26645,    9550},
+{ -25549,     477,    7874,   -1538,    1123,    -168},
+{    470,    9834,    -347,   23945,  -10381,   -9467},
+{  -4096,   -9702,   -6856,  -21544,   20845,    7174},
+{   5370,    9748,  -23765,   -1190,     512,   -1538},
+{  -1006,  -10046,  -12649,   19234,   -1790,    -890},
+{  15108,   23620,  -15646,   -2522,   -1203,   -1325},
+{  -7406,   -2605,    1095,    -247,    -473,     177},
+{   8089,       4,   12424,  -22284,   10405,   -7728},
+{  22196,   10775,   -5043,     690,     534,    -212},
+{  -3153,   -1418,  -16835,   18426,   15821,   22956},
+{   5681,   -2229,    3196,   -3414,  -21817,  -14807},
+{     19,     787,    1032,     170,   -8295,    -645},
+{   -882,   -2319,  -27105,     432,   -4392,    1499},
+{  -1354,  -11819,     -76,  -20380,  -10293,   11328},
+{    211,   -4753,   -4675,   -6933,  -13538,   14479},
+{   6043,    5260,    -459,    -462,     143,     -65},
+{  -2572,    7256,   -3317,    9212,  -23184,   -9990},
+{ -24882,   -9532,   18874,    6101,    2429,  -14482},
+{   8314,    2277,   14192,    3512,   25881,   22000},
+{    208,   20218,    -281,  -24778,     -63,   -1183},
+{   1095,   -6034,    2706,  -21935,   -2655,     563},
+{     23,   -5930,     243,   -8989,    5345,   20558},
+{ -15466,   12699,    4160,   11087,   20621,  -10416},
+{  20995,     -85,   -8468,     194,    1003,   -9515},
+{ -19637,   -3335,  -14081,    3574,  -23381,    -667},
+{  -2076,    3489,   -3192,  -19367,     539,   -1530},
+{   7352,  -15213,   22596,   19369,    1043,   16627},
+{  -1872,    -413,    1235,   -5276,   -3550,   21903},
+{   7931,   -2008,   16968,   -6799,   29393,   -2475},
+{ -13589,    8389,  -23636,  -22091,  -14178,  -14297},
+{ -11575,  -20090,   16056,   -1848,   15721,    4500},
+{   3849,  -16581,   20161,  -21155,    7778,   11864},
+{  -6547,   -1273,  -18837,  -11218,   11636,    1044},
+{   2528,   -6691,  -17917,  -11362,   -4894,   -1008},
+{   1241,    4260,    2319,    6111,    3485,   20209},
+{   3014,   -3048,    5316,   -4539,   20831,    8702},
+{  -1790,  -14683,     278,   13956,  -10065,  -10547},
+{ -22732,   -7957,   -1154,   13821,   -1484,   -1247},
+{  -7317,    -615,   13094,   18927,    9897,    1452},
+{   2552,   -2338,    3424,   -4630,   11124,  -19584},
+{ -11125,  -20553,  -10855,  -10783,  -20767,    6833},
+{    984,  -15095,    5775,   25125,    5377,  -19799},
+{    517,   13272,   -7458,   -1711,   20612,   -6013},
+{ -21417,   13251,  -20795,   13449,   17281,   13104},
+{ -15811,  -16248,   23093,   -4037,   -8195,     871},
+{    582,   12571,  -21129,  -14766,   -9187,    5685},
+{   4318,   -1776,   11425,  -17763,   -9921,     577},
+{   6013,   16830,   17655,  -25766,   -4400,   -3550},
+{ -13744,  -16541,    3636,   -3330,  -21091,  -15886},
+{   6565,  -11147,    8649,  -13114,   23345,  -13565},
+{  -2542,   -9046,   -7558,   29240,    3701,    -383},
+{ -10612,   24995,    1893,   -8210,   20920,  -16210},
+{   5276,   16726,   10659,   19940,   -4799,  -19324},
+{   -532,   -9300,   27856,    4965,    -241,     536},
+{   -765,  -20706,   -3412,   18870,    2765,    1420},
+{  -3059,    2708,  -19022,    -331,    3537,     116},
+};
+const int16_t ff_vq_hebap7[512][6] = {
+{ -21173,   21893,   10390,   13646,   10718,   -9177},
+{ -22519,   -8193,   18328,   -6629,   25518,  -10848},
+{   6800,  -13758,  -13278,   22418,   14667,  -20938},
+{   2347,   10516,    1125,   -3455,    5569,   27136},
+{  -6617,   11851,  -24524,   22937,   20362,   -6019},
+{ -21768,   10681,  -19615,  -15021,   -8478,   -2081},
+{  -2745,    8684,   -4895,   27739,    7554,  -11961},
+{  -1020,    2460,    -954,    4754,    -627,  -16368},
+{ -19702,   23097,      75,  -13684,   -2644,    2108},
+{   4049,   -2872,    5851,   -4459,   22150,   12560},
+{ -21304,  -17129,    -730,    7419,  -11658,  -10523},
+{  11332,    1792,   26666,   23518,  -19561,    -491},
+{ -17827,  -16777,  -13606,  -14389,  -22029,   -2464},
+{   1091,   -5967,   -7975,  -16977,  -20432,  -21931},
+{  18388,   -1103,    1933,   13342,  -17463,   18114},
+{  22646,   17345,   -9966,   17919,   18274,     698},
+{   1484,   20297,   -5754,  -26515,    4941,  -22263},
+{  -2603,    4587,   -5842,   18464,    8767,   -2568},
+{  -2797,   -1602,   21713,    3099,  -25683,    3224},
+{ -19027,    4693,   -5007,    6060,    1972,  -15095},
+{  -2189,    9516,    -530,   20669,   -4662,   -8301},
+{ -22325,   -8887,    2529,  -11352,    5476,     998},
+{  22100,   -5052,    1651,   -2657,    4615,    2319},
+{  20855,   -3078,   -3330,    4105,   13470,    3069},
+{     85,   17289,   10264,  -14752,     214,      90},
+{ -26365,  -18849,  -19352,   19244,  -10218,    9909},
+{  -9739,   20497,   -6579,   -6983,    2891,    -738},
+{  20575,  -15860,  -22913,    6870,      76,     327},
+{   8744,  -12877,  -22945,   -2372,  -19424,   -9771},
+{ -12886,   16183,   21084,    3821,     749,  -13792},
+{ -15995,   18399,    2391,  -17661,   19484,   -6018},
+{   1423,   11734,    4051,   19290,    6857,  -19681},
+{  -5200,    9766,   18246,    2463,   18764,   -4852},
+{   -597,   19498,    1323,   -9096,    -308,   -1104},
+{  -3099,  -25731,  -15665,   25332,    4634,    2635},
+{  19623,   -2384,   -7913,   11796,   -9333,  -14084},
+{   2642,   26453,  -21091,  -10354,   -1693,   -1711},
+{  22031,   21625,   11580,  -22915,   -4141,     129},
+{  -6122,    3542,     915,    -261,     -17,    -383},
+{   1696,    6704,   -1425,   20838,     857,   -4416},
+{   1423,  -15280,   -8550,   -9667,    5210,    5687},
+{  -4520,    -613,  -11683,    5618,    4230,     619},
+{    937,   -4963,  -14102,  -17104,   -6906,   -5952},
+{ -15068,    -481,   -7237,  -14894,   18876,   21673},
+{ -25658,    2910,    1143,    -327,    -458,    -995},
+{  -9656,    -819,  -24900,    2804,   20225,    1083},
+{  -1111,   -3682,   -1788,  -19492,     966,     821},
+{   7293,  -21759,   10790,   -7059,  -23293,   -1723},
+{   -282,  -11093,     170,  -20950,  -28926,   12615},
+{  17938,    3713,   -1563,     885,       5,     564},
+{   6116,   22696,    2242,   -6951,    9975,   -6132},
+{   4338,   26808,   -3705,    1976,   -1079,   -2570},
+{   -661,   -7901,   -2668,  -15194,   17722,    4375},
+{  -4174,  -11053,     717,  -22506,    1562,   12252},
+{  -6405,   18334,    6103,    6983,    5956,   18195},
+{   9851,    5370,   23604,   -6861,   -6569,     -62},
+{  21964,   13359,    -683,    3785,    2168,     209},
+{  -3569,   -1127,  -19724,   -1544,    1308,    -803},
+{  -3083,   16049,  -13791,   -3077,    4294,   23713},
+{  -9999,    9943,  -15872,   12934,  -23631,   21699},
+{   9722,   22837,   12192,   15091,    5533,    4837},
+{   2243,    2099,    1243,    4089,    4748,   12956},
+{   4007,   -2468,    3353,   -3092,    8843,   17024},
+{   4330,    6127,    5549,    9249,   11226,   28592},
+{  -9586,   -8825,     236,    1009,     455,    -964},
+{   6829,   19290,   -1018,     200,    1821,     578},
+{   5196,     957,   10372,    3330,  -12800,    -127},
+{  -3022,   -8193,  -14557,   22061,    5920,    1053},
+{  10982,   25942,  -24546,  -23278,  -11905,   -6789},
+{  22667,  -11010,    5736,    2567,   23705,  -10253},
+{  -3343,   -4233,   -5458,   20667,  -10843,   -3605},
+{  -4131,   -3612,    4575,    -829,    -350,    -847},
+{  -3303,    3451,   -7398,  -11604,    3023,     455},
+{   3200,   -9547,    3202,  -22893,   11184,  -26466},
+{ -14093,   -4117,   15382,   14295,  -10915,  -20377},
+{   3807,  -11016,   22052,   14370,  -15328,   -7733},
+{  -6291,  -17719,   -1560,   12048,  -19805,    -443},
+{  -6147,   -4234,    -160,    8363,   22638,   11911},
+{  19197,    1175,    7422,   -9875,   -4136,    4704},
+{    -72,   -7652,    -112,  -11955,   -3230,   27175},
+{   3274,    5963,    7501,  -17019,     866,  -25452},
+{    737,    1861,    1833,    2022,    2384,    4755},
+{  -5217,    7512,    3323,    2715,    3065,   -1606},
+{   4247,     565,    5629,    2497,   18019,   -4920},
+{  -2833,  -17920,   -8062,   15738,   -1018,    2136},
+{   3050,  -19483,   16930,   29835,  -10222,   15153},
+{ -11346,     118,  -25796,  -13761,   15320,    -468},
+{  -4824,    4960,   -4263,    1575,  -10593,   19561},
+{  -8203,   -1409,    -763,   -1139,    -607,    1408},
+{  -2203,  -11415,    2021,   -6388,   -2600,     711},
+{   -413,   -2511,    -216,   -3519,  -28267,    1719},
+{ -14446,   17050,   13917,   13499,  -25762,  -16121},
+{  19228,    7341,  -12301,     682,   -3791,    -199},
+{  -4193,   20746,  -15651,   11349,    5860,    -824},
+{ -21490,   -3546,      -3,   -1705,   -3959,    9213},
+{  15445,   -1876,    2012,  -19627,   16228,   -4845},
+{  -2867,   -3733,   -7354,    -175,  -20119,   11174},
+{  -3571,  -24587,   19700,    6654,     979,    -654},
+{  21820,   -7430,   -6639,  -10767,   -8362,   15543},
+{  14827,   17977,   -7204,   -3409,    1906,  -17288},
+{   3525,   -3947,   -1415,   -2798,   17648,    2082},
+{  -6580,  -15255,  -17913,    1337,   15338,   21158},
+{   6210,    9698,   15155,  -24666,  -22507,   -3999},
+{  -1740,    -593,    1095,   -7779,   25058,    5601},
+{  21415,    -432,   -1658,   -6898,   -1438,  -14454},
+{  -6943,     700,  -12139,    -745,  -24187,   22466},
+{   6287,    3283,   11006,    3844,   19184,   14781},
+{ -22502,   15274,    5443,   -2808,    -970,   -3343},
+{   3257,   -3708,    4744,   -8301,   22814,  -10208},
+{  24346,  -20970,   19846,     987,  -11958,   -6277},
+{   3906,  -19701,   13060,   -1609,   18641,    7466},
+{ -26409,  -22549,   16305,    2014,   10975,   18032},
+{  -7039,    4655,  -14818,   18739,   15789,    1296},
+{   9310,   -1681,   14667,   -3326,   26535,  -11853},
+{   5728,    5917,   13400,   10020,   -2236,  -24704},
+{   1741,   -6727,   12695,  -22009,    4080,    5450},
+{  -2621,    9393,   21143,  -25938,   -3162,   -2529},
+{  20672,   18894,  -13939,    6990,   -8260,   15811},
+{ -23818,   11183,  -13639,   11868,   16045,    2630},
+{  18361,  -10220,     829,     856,   -1010,     157},
+{  14400,   -4678,    5153,  -13290,  -27434,  -11028},
+{  21613,   11256,   17453,    7604,   13130,    -484},
+{      7,    1236,     573,    4214,    5576,   -3081},
+{    916,   -9092,    1285,   -8958,    1185,  -28699},
+{  21587,   23695,   19116,   -2885,  -14282,   -8438},
+{  23414,   -6161,   12978,    3061,   -9351,    2236},
+{  -3070,   -7344,  -20140,    5788,     582,    -551},
+{  -3993,     315,   -7773,    8224,  -28082,  -12465},
+{  13766,  -15357,   19205,  -20624,   13043,  -19247},
+{   3777,    -177,    8029,   -1001,   17812,    5162},
+{  -7308,   -4327,  -18096,    -620,   -1350,   14932},
+{  14756,   -1221,  -12819,  -14922,    -547,   27125},
+{   2234,    1708,    2764,    5416,    7986,  -25163},
+{   2873,    3636,    3992,    5344,   10142,   21259},
+{   1158,    5379,     508,  -10514,     290,   -1615},
+{   1114,   24789,   16575,  -25168,    -298,   -2832},
+{  -1107,   -6144,   -1918,   -7791,   -2971,  -23276},
+{   4016,   10793,   17317,   -4342,  -20982,   -3383},
+{  -4494,    -207,   -9951,   -3575,    7947,    1154},
+{  -7576,    8117,  -14047,   16982,  -26457,  -27540},
+{ -15164,   16096,  -16844,   -8886,  -23720,   15906},
+{  24922,    5680,   -1874,     420,     132,     117},
+{   -506,  -19310,    -198,     412,    -311,     752},
+{  -1906,    3981,   -7688,   16566,  -19291,  -14722},
+{   -399,    -729,   -3807,   -4196,  -12395,    7639},
+{   3368,    2330,    9092,   23686,  -10290,   -1705},
+{  -3148,    2596,   -7986,   14602,   -4807,   16627},
+{   8057,    1481,      49,   17205,   24869,    7474},
+{ -19304,    -513,   11905,    2346,    5588,    3365},
+{  -5063,  -21812,   11370,   10896,    4881,     261},
+{   4794,   20577,    5109,   -6025,   -8049,   -1521},
+{   8125,  -14756,   20639,  -14918,   23941,   -3650},
+{  12451,    1381,    3613,    8687,  -24002,    4848},
+{   6726,   10643,   10086,   25217,  -25159,   -1065},
+{   6561,   13977,    2911,   21737,   16465,  -26050},
+{  -1776,    2575,  -19606,  -16800,    3032,    6679},
+{  15012,  -17910,   -8438,  -21554,  -27111,   11808},
+{   3448,    -924,  -15913,   -1135,    5126,  -20613},
+{   7720,    2226,   17463,    5434,   28942,   17552},
+{   1246,   15614,  -11743,   24618,  -17539,    3272},
+{   3215,   17950,    2783,    -722,  -22672,    5979},
+{  -5678,   -3184,  -26087,   26034,    6583,    3302},
+{  20310,   -3555,   -2715,    -444,   -1487,    1526},
+{ -20640,  -21970,  -12207,  -25793,    8863,   -1036},
+{  17888,     570,  -16102,    8329,   -2553,   15275},
+{  -2677,    9950,   -1879,   16477,  -12762,  -29007},
+{   -120,   -2221,     219,      97,     365,      35},
+{   1270,    -718,    1480,   -2689,    1930,   -7527},
+{   1896,    8750,    1906,   18235,  -12692,   -6174},
+{  -3733,   13713,   -9882,  -15960,   -1376,   -7146},
+{ -10600,    8496,   15967,   -8792,    7532,   20439},
+{   3041,  -13457,    1032,  -26952,    5787,   24984},
+{  -4590,   -8220,   -9322,   -6112,  -17243,   25745},
+{ -17808,    6970,    3752,     626,    -114,    2178},
+{   4449,   -4862,    7054,   -5404,    4738,   -2827},
+{   4922,    -651,   18939,   -9866,     848,    1886},
+{   -336,   -5410,    7234,   20444,   -9583,    -600},
+{    781,  -19474,  -12648,    6634,    1414,     450},
+{  -3399,  -16770,   11107,   13200,   -5498,   21663},
+{  -3265,    4859,   -5961,    7530,  -10837,   28086},
+{  10350,  -12901,   25699,   25640,    -639,     351},
+{   1163,   18763,   -5466,  -15087,    -145,   -1377},
+{ -14477,   27229,  -31383,  -32653,   21439,   -2894},
+{  15420,   18823,   22128,   19398,   22583,   13587},
+{ -10674,   10710,    5089,   -4756,     909,  -20760},
+{ -12948,  -20660,    7410,    2722,    3427,   11585},
+{  -1105,   18374,   19731,   -9650,   22442,   19634},
+{   -296,   -6798,  -14677,   21603,   19796,   21399},
+{ -19350,   -7501,   25446,   13144,    8588,  -25298},
+{   3092,  -10618,   20896,    9249,   -3326,    1796},
+{   -811,    1449,    3106,    4748,   12073,  -14262},
+{ -20720,   14275,   -4332,  -25838,   -5781,  -21149},
+{  -5132,   10554,  -14020,  -22150,    2840,    -554},
+{  25533,   17648,   14886,  -21074,    2459,   25142},
+{  -9370,   -1788,  -12862,   -5870,  -25811,  -11023},
+{   6698,     819,   10313,     166,   27581,     523},
+{    101,  -19388,    3413,    9638,      64,     806},
+{  -2742,  -17931,   -2576,   22818,    8553,    1126},
+{   2972,   15203,    1792,   25434,   -5728,  -17265},
+{  -1419,    1604,    4398,   11452,    1731,   23787},
+{  -5136,    4625,  -10653,   27981,    9897,   -2510},
+{ -10528,  -28033,    2999,   -1530,    -832,    -830},
+{ -11133,  -12511,   22206,   -7243,  -23578,  -21698},
+{  16935,  -21892,    1861,   -9606,    9432,   19026},
+{  10277,    9516,   26815,    2010,   -4943,   -9080},
+{   5547,   -2210,   14270,  -15300,  -19316,    1822},
+{  -4850,    -783,   -8959,   -3076,  -20056,   -3197},
+{   8232,   -2794,  -17752,   13308,    3229,    -991},
+{ -12237,   -6581,   10315,   -9552,    2260,  -20648},
+{  -7000,    5529,   -7553,   -7490,  -10342,  -10266},
+{   3641,   19479,   -5972,  -19097,  -18570,   12805},
+{   1283,   -4164,    4198,  -28473,   -2498,    1866},
+{  16047,   26826,  -13053,   -6316,     985,   -1597},
+{   -403,   13680,    6457,   25070,   27124,  -20710},
+{ -18070,   -1790,  -24986,    5953,    -954,   26600},
+{ -24224,  -15383,   24788,    1953,   -1136,     187},
+{  -2289,   12505,  -20738,    -904,   18324,   21258},
+{   2658,   -6140,   16179,   22276,    -556,    2154},
+{  -6087,   13950,  -25682,  -27713,    4049,   -4795},
+{ -21452,   26473,   19435,   -9124,     895,     303},
+{ -22200,  -26177,   -6026,   24729,  -22926,   -9030},
+{ -14276,  -15982,   23732,  -22851,    9268,   -3841},
+{  29482,   21923,   -6213,    1679,   -2059,   -1120},
+{   -435,    9802,   -3891,   12359,   -4288,  -18971},
+{  19768,     -86,    2467,    1990,   -1021,   -5354},
+{  20986,   -8783,   -5329,  -23562,   -4730,    2673},
+{  -5095,    5605,   -4629,   19150,   26037,  -12259},
+{    972,    6858,    4551,   27949,   -4025,   -2272},
+{   6075,   -3260,   -4989,    -373,   -1571,   -3730},
+{  -7256,  -12992,   -8820,   -5109,   23054,    5054},
+{    920,    2615,    7912,   -7353,   -4905,   20186},
+{   -250,    5454,    3140,    6928,  -18723,   -2051},
+{ -10299,   -4372,   19608,    4879,    -661,   -1885},
+{  14816,   -8603,  -19815,    6135,  -21210,   14108},
+{ -11945,   -2223,    5018,   11892,   22741,     406},
+{ -13184,   -2613,  -13256,  -22433,  -12482,   -8380},
+{  17066,   25267,   -2273,    5056,    -342,     145},
+{   8401,  -17683,   19112,   10615,  -19453,   17083},
+{  20821,   -5700,   12298,  -25598,   10391,    7692},
+{   4550,   15779,   17338,  -19379,   -4768,    1206},
+{  -7723,   10836,  -27164,  -11439,    6835,   -1776},
+{   2542,    3199,    4442,   17513,   -3711,    -914},
+{  20960,  -16774,   -5814,   11087,     -70,   22961},
+{   3305,    2919,    6256,   -4800,  -20966,   -3230},
+{   5924,  -16547,    2183,    2733,    3446,  -23306},
+{  -6061,    -194,  -13852,  -10971,   19488,    1029},
+{   4467,   -5964,  -19004,    1519,    -359,     855},
+{  -1581,   -7607,   22070,  -11580,  -10032,   17102},
+{ -12412,    2553,    4324,   22500,    5751,   12170},
+{ -25127,   17996,   -6384,    1180,    1182,    9622},
+{  23462,   -8471,   -4392,   -2669,    7638,  -16835},
+{  -5511,   -2887,  -10757,  -20883,    7246,    1053},
+{   2703,  -20602,   -7554,    7516,   -7740,    5868},
+{  20670,   21901,     457,   14969,  -17657,  -11921},
+{   3603,   -1595,   -2177,    -157,     -43,     605},
+{   2513,    8954,   10527,   22559,  -16100,  -16041},
+{   6002,    4951,    6795,   -4862,  -22400,   18849},
+{   7590,   -1693,  -24688,   -3404,   14169,    1214},
+{  -4398,   -6663,   -6870,  -10083,  -24596,    9253},
+{  10468,   17751,   -7748,     147,   -6314,    4419},
+{  16187,  -16557,   -4119,    4302,    7625,    5409},
+{   3303,    2735,    7458,  -19902,   -2254,   -3702},
+{  -2077,   21609,   14870,   12545,   -6081,   -1764},
+{   4678,   11740,    2859,    6953,    1919,   -3871},
+{   3522,  -21853,   -2469,  -10453,   18893,  -10742},
+{   3759,  -10191,   -4866,   -2659,  -17831,   -1242},
+{  14991,    9351,   11870,   -1573,   -4848,   22549},
+{   9509,  -27152,   10734,   20851,  -26185,  -17878},
+{  -7170,   -1392,  -19495,   12746,    8198,   -1988},
+{   1883,   28158,    -846,   -7235,     249,     233},
+{  -7200,     669,    -371,   -2948,   23234,   -5635},
+{   3141,     288,    3223,   -1258,     -98,  -27607},
+{  17373,  -23235,    5110,  -11199,   -2574,  -11487},
+{  -4928,    1518,   -5456,     670,  -18278,    1951},
+{  10334,  -19865,   -4649,     361,    -160,    -923},
+{  18732,   14264,   -3155,   -7485,   -3328,    5959},
+{  -3614,   21077,    7276,    3536,    8121,   -1528},
+{  -8422,     500,  -19182,   18929,   26392,   -1039},
+{  15639,   25668,    8375,    1903,    1945,  -11979},
+{  -2716,    3389,   26850,   -4587,    1803,      22},
+{   1177,    -655,    1233,   -2128,    7844,    1767},
+{   -761,    8209,  -19290,   -4593,    1923,    -343},
+{   -689,   -3530,   -3267,   -3804,   -2753,   18566},
+{  -2110,    1962,   -1353,   16643,    2765,  -23102},
+{   -433,    4905,     302,   13016,   15933,   -5905},
+{   3203,    4126,   11181,   -5496,   -2529,   -1160},
+{  -1091,   -6469,   -1415,    5682,    -268,     583},
+{  -9405,  -19572,    6216,    1658,     993,     -75},
+{  -1695,   -4504,   -2289,   -4088,   -6556,  -16577},
+{   4760,    -892,  -10902,    6516,   24199,   -6011},
+{   -253,    1000,      63,     -81,    -115,    -382},
+{  -1333,   24224,    -698,   -4667,   -2801,  -19144},
+{   -876,  -28866,  -21873,   12677,   -6344,    3235},
+{  16847,   21145,  -26172,   -3183,    -396,     230},
+{  18296,   -7790,  -12857,    -679,   -1473,       5},
+{ -10488,   11429,   25805,   -1122,    1401,    -438},
+{   3782,   -7429,   26720,   17567,   19257,   12542},
+{   6332,    -746,   12789,    9316,  -22542,   -5354},
+{   3418,  -22728,   26978,   18303,    1076,     956},
+{ -27315,   -2988,     920,     235,    2233,      81},
+{   6199,    5296,   16093,   14768,   -8429,   -1112},
+{  -6432,   19244,    9921,   -3253,    1278,    -954},
+{  24213,    2049,  -22931,    2585,   -2410,   -4216},
+{   9286,   14282,  -19735,   -3985,   -2344,    1028},
+{ -20128,   17993,   -9458,   23012,  -16983,    8625},
+{  -6896,  -20730,    3762,   17415,   22341,   19024},
+{    842,   24181,   25062,   -5839,     -78,     937},
+{   -621,   19722,  -24204,   -1962,  -14854,     -56},
+{  22766,   -5119,   17365,   23868,  -19480,   -6558},
+{  -2158,   17490,  -21435,    3340,  -12819,  -20295},
+{  -9621,   17325,     715,    2265,   -4123,    -492},
+{   9156,   12947,   27303,  -21175,   -6072,   -9457},
+{ -13164,  -23269,  -14006,   -4184,    6978,       2},
+{    938,  -13381,    3520,  -24297,   22902,   19589},
+{  -4911,  -19774,   19764,   -9310,  -12650,    3819},
+{  -5462,   -4249,   -6987,   -6260,  -13943,  -25150},
+{   9341,   10369,  -13862,   -6704,   22556,    -519},
+{   6651,   18768,   -4855,   12570,   14730,  -10209},
+{   -823,   18119,     398,   -1582,    -116,    -363},
+{  -6935,  -12694,  -28392,    8552,    6961,    -239},
+{  -2602,   -4704,   -1021,    2015,    5129,   23670},
+{ -12559,   -8190,  -25028,   18544,   14179,    1663},
+{   3813,   21036,   -9620,   -5051,   -1800,   -1087},
+{ -22057,   16675,   14960,    9459,    2786,   16991},
+{ -26040,  -19318,   -6414,    1104,    5798,  -18039},
+{  -1737,   24825,   10417,  -11087,     896,   -5273},
+{  -1855,   11661,   -2803,   24809,  -21435,  -19792},
+{ -23473,  -16729,   -5782,    5643,    2636,    4940},
+{  -1724,    4388,  -26673,  -13695,   10570,  -25895},
+{  15358,  -19496,   26242,  -18493,    1736,    8054},
+{   5684,   20890,    4091,  -19100,  -14588,  -10468},
+{  17260,  -16291,   14859,  -17711,  -19174,   12435},
+{ -27185,  -12573,    6743,    -562,     976,    -257},
+{  12395,   -8618,  -22248,  -19843,   11013,    7762},
+{   3799,   11853,  -27622,   -8473,    1089,   -1495},
+{   4141,   -2182,  -26720,    -735,    -774,    1469},
+{   3125,   13762,    4606,   29257,   18771,   -9958},
+{ -17465,   -9445,  -17562,   -2530,   -6435,   -3726},
+{  -1742,    4351,   -6841,  -19773,    9627,  -10654},
+{   7251,    3525,   10835,    5601,   25198,  -23348},
+{ -10300,  -17830,     631,   11640,    2044,  -20878},
+{   -873,   -8502,   -1063,  -15674,  -10693,   14934},
+{ -15957,   28137,    5268,     477,   -1053,    1158},
+{  -1495,   -8814,   -5764,  -24965,   25988,    7907},
+{  -1038,    -114,   -2308,   -1319,   -6480,    1472},
+{   4895,  -17897,  -25850,    5301,    -188,    1581},
+{   3200,   17225,    4346,   22101,  -18543,   22028},
+{ -10250,     545,  -10932,    2276,  -28070,    8118},
+{  15343,    2329,    9316,   20537,   14908,   21021},
+{   6329,    6130,  -24508,     837,   -8637,   -5844},
+{   7386,    -501,   10503,   20131,   11435,   -4755},
+{  -2745,   24174,   -9274,   15273,   -8389,   -5835},
+{   2992,   -2864,    6048,   -7473,   11687,  -19996},
+{   -883,  -11954,   -9976,  -21829,   -4436,  -27178},
+{   3458,   19626,    1280,    2597,   19849,    5255},
+{  -5315,   19133,  -14518,   -8946,   13749,   -1352},
+{  18642,   17655,   11001,    6817,  -18418,    6336},
+{  -1697,    2244,   -4640,    3948,  -12890,   -5273},
+{  20428,   10542,    4170,   -1012,   19439,   21691},
+{  -2943,  -19735,   -4208,    1320,     909,   -8897},
+{   9351,   -8066,   -2618,  -12933,   26582,    3507},
+{   9705,  -22628,    8311,    8167,  -13293,    5608},
+{   3222,    3749,   -1508,     165,     -52,    -196},
+{    102,  -22744,   -8832,     903,  -11421,  -14662},
+{   -120,    5998,   19765,   13401,    3628,    5197},
+{   8528,    5827,   -1066,     774,     -39,    -166},
+{   9411,   -9476,    9581,  -13004,   24456,   24900},
+{  17878,    2235,  -21639,   20478,    4716,   -7190},
+{  -2482,    9511,    1611,  -21943,   14230,   -1289},
+{   9288,   -2291,   23215,   -3452,  -10842,      11},
+{   9496,    3041,    5130,   -3890,  -21219,  -22589},
+{  14262,   -9838,   20195,   14019,      91,  -17200},
+{ -18591,     980,      17,     821,     120,    -574},
+{  12285,  -19269,   13742,   16373,    -161,    6025},
+{  -3364,    1530,   -4005,    2454,  -10872,  -23839},
+{    105,    5085,    -260,    5790,    -588,   19170},
+{   4121,    4169,   13439,   14644,   20899,    7434},
+{   -175,   13101,   -3704,   23233,    3907,   10106},
+{  -6101,   23467,    5204,   -1341,    1599,   13174},
+{  -3217,   -3494,   15117,   -8387,  -11762,   -4750},
+{   1146,    4675,  -19378,   14917,   -5091,     249},
+{ -21506,   10136,  -16473,  -13305,   18382,   -8601},
+{    628,    2447,    3344,    3130,   -5115,     119},
+{  17900,  -22422,  -17633,   21967,  -16293,   -7676},
+{  16863,   24214,    5612,   -3858,    -809,    3822},
+{  -2291,   10091,   -2360,  -25109,   -1226,     312},
+{   2957,   11256,   26745,  -13266,   -3455,   -1128},
+{ -19762,   -2708,    4604,    6355,    1638,   25501},
+{ -19593,   -7753,    3159,     -85,    -489,   -1855},
+{    814,   12510,   19077,   -4681,   -2610,   -1474},
+{ -23408,  -19027,    8137,   19878,    7912,    -282},
+{    839,  -19652,   11927,   27278,   -3211,    2266},
+{   4020,   -1110,    8226,   -1274,   20922,   25060},
+{  26576,     325,   -8693,    -232,   -2218,    -699},
+{ -11293,   -4200,    1805,   -6673,  -22940,   -1339},
+{  -2005,  -15886,   -1047,  -27687,  -13235,   14370},
+{ -22073,    1949,   13175,  -15656,   -1846,    8055},
+{   3039,   12025,    7132,  -24632,     413,   -2347},
+{ -24048,    -206,   12459,   -6654,    -417,  -10091},
+{  18179,  -23688,  -20515,  -16396,    7230,     763},
+{   5659,   -5085,   13878,  -23729,  -11077,  -19587},
+{  11340,     501,   25040,    7616,  -19658,    1605},
+{ -26650,    8878,   10544,     417,    1299,     261},
+{  14460,   11369,   -3263,    9990,    8194,   18111},
+{   1355,  -20838,   -9196,  -16060,   -8559,    -730},
+{  -1918,  -20937,  -18293,   -2461,   -2651,    4316},
+{  -2810,   24521,  -10996,  -25721,     308,   -1234},
+{  -9075,  -17280,   -1833,  -29342,  -24213,  -16631},
+{  -2843,   10165,   -5339,   -2888,   21858,  -21340},
+{ -15832,   14849,  -23780,    5184,   10113,  -20639},
+{ -19535,  -11361,    8413,    1486,  -23658,   -5759},
+{  -7512,    1027,  -20794,   13732,   19892,  -21934},
+{ -12132,   -7022,  -19175,   -8840,   22125,  -16490},
+{   1937,    5210,   -6318,  -23788,   13141,   11082},
+{   -205,    6036,    -380,    8658,    -233,   28020},
+{  -5523,    7477,    7635,   23595,    9763,   -2590},
+{  21658,  -28313,   -3086,    -300,   -1032,    1744},
+{ -22352,   16646,     208,    6665,  -17400,   -3028},
+{  18482,    9336,   -2737,  -19372,     407,   -4389},
+{  -4913,  -17370,   18819,  -17654,   13416,   15232},
+{   7749,    6368,   23135,  -18174,    7584,   -4248},
+{  -1489,   -6523,     586,  -10157,   14964,   25568},
+{   3844,   -6156,    4897,  -13045,  -22526,    5647},
+{  -8491,   -2105,  -24774,     905,   -9326,    1456},
+{  -3040,   -1476,    1166,   -4428,   11236,    9204},
+{   3397,   -1451,   13598,  -15841,   24540,    5819},
+{   8483,   -2993,   21547,  -16916,    7741,   24018},
+{ -14932,  -23758,   -5332,   -6664,   -4497,   13267},
+{  19379,   12916,   -2142,    -737,   21100,  -22101},
+{   3393,   -4629,    5735,  -18913,   -6969,    2687},
+{   1148,  -16147,  -21433,  -28095,    -630,  -14449},
+{   7300,     672,   18530,  -17452,  -10149,     351},
+{  11356,  -10974,   17212,    4624,     145,   17791},
+{   -711,   -3479,   -2238,   15887,    2027,       0},
+{ -28048,    1794,    -593,   -2758,  -21852,   11535},
+{ -19683,    4937,   22004,   21523,   -3148,    1790},
+{    813,    8231,    2633,   11981,   -3043,   22201},
+{   8952,  -24760,    -690,   14873,   -2366,   -5372},
+{   8406,   -5439,    -274,    -642,    -145,     778},
+{  -6605,    7258,   20780,  -23507,  -18625,   22782},
+{ -22896,  -25488,   10020,   -1614,    1508,   -1393},
+{   7607,     407,  -24678,  -16385,   -1804,   -4699},
+{ -10592,  -19139,   10462,   -3747,    8721,   -6919},
+{  13010,    5292,   -6230,   -4884,  -20904,   -1797},
+{  16891,  -13770,    -465,   19343,  -10741,  -12959},
+{  25193,  -14799,   -5681,    -521,    -321,   -1211},
+{   6917,   -3093,   20183,  -26903,  -12026,    1295},
+{    305,    1992,   19457,    -985,      25,    -521},
+{   6707,   -3698,    8365,   -8687,   21921,  -27166},
+{   4668,    5997,    7117,   11696,   24401,  -10794},
+{    744,   -9416,   19893,    1963,    7922,   -9824},
+{   3430,   21282,   -1736,   10844,    8821,   27015},
+{  -8813,    1521,  -24038,    1651,    7838,   -1208},
+{   3911,  -11221,    3273,  -12541,    7168,   18402},
+{  21642,    9117,  -11536,   -5256,    7077,    2382},
+{    100,    3817,   -6713,    1244,    1518,    -321},
+{   7946,  -18670,   10667,   -4866,     727,     776},
+{ -15883,   -8150,   -2087,   22739,    1567,   -3482},
+{   4380,   -2735,    8469,   -7025,  -11424,    1317},
+{  26970,    4393,    7665,   17561,    -714,     650},
+{ -16191,    -835,    8365,    1795,  -14314,   16297},
+{   4504,  -10048,    7662,  -26690,  -17428,    2580},
+{     48,   -3984,     564,   -5871,    2658,  -18658},
+{  12579,  -26016,  -15642,    2672,   -1347,    -887},
+{  -4950,    4208,   -6811,    2569,  -20621,   -8658},
+{  -1836,  -14818,   -5571,  -23322,  -14800,   25867},
+{   5434,  -28139,   -2357,   -2883,    -570,    2431},
+{  13096,   -2771,   24994,  -12496,  -24723,   -1025},
+{  -5676,   -4339,    1908,   18628,  -21323,   17366},
+{  27660,  -27897,  -15409,    1436,   -7112,   -2241},
+{   8019,    3847,   24568,    -469,    9674,   10683},
+{   -903,  -10149,    1801,  -21260,    4795,   -8751},
+{   1122,   -9582,    2625,   22791,     956,     882},
+{   7876,   19075,   -9900,  -24266,    7496,    9277},
+{    980,  -26764,   -5386,    5396,    1086,    1648},
+{  28838,   -1270,    -447,       5,    -429,     -20},
+{ -15283,    6132,   22812,    1252,   -9963,     511},
+{    851,    7925,    -457,  -12210,    4261,    7579},
+{  -4530,    8452,   -1246,   14501,  -24951,   -5760},
+{ -17814,  -10727,    9887,  -23929,  -13432,    1878},
+{ -15049,   10165,   16491,  -14603,  -11712,  -21156},
+{  -3317,     840,   -5683,   22413,    1994,     586},
+{  23158,   -5788,  -15043,  -10372,   -9271,  -13523},
+{   -773,   -9509,   -3993,  -24264,    8463,    5804},
+{  -8545,    -703,  -12440,   -3985,  -25122,  -28147},
+{ -16659,   16001,    2746,    1611,    5097,   -1043},
+{     41,   -7181,   19903,   31555,  -32237,   13927},
+{  -5658,     845,  -12774,    5705,   16695,     -86},
+{   5282,   14875,   27026,   21124,   15776,  -10477},
+{  14712,   19648,  -11487,  -13361,  -20196,  -15229},
+{   8597,   -9138,    -626,   10891,   -6015,    6346},
+{  -1488,   -1272,   -1479,   -1303,   -3704,   -5485},
+{  -3370,   17871,   -6604,   24930,   25886,   -3127},
+{   8416,   27783,   -1385,    5350,   -4260,   19993},
+{   5688,     362,   17246,    3809,   -3246,    1088},
+{   -105,  -29607,    2747,   15223,    -167,    3722},
+{   3502,   -3195,    8602,    7772,   -1566,    -915},
+{   -491,    3257,   -2423,    5522,   20606,    -100},
+{ -13948,  -11368,  -15375,  -21866,   -8520,   12221},
+{   -616,    2424,   -2023,    4398,   -3805,    8108},
+{  -7204,   21043,   21211,   -9395,  -19391,     896},
+{  -5737,  -15160,  -21298,   17066,   -1006,    -366},
+{   6261,    3240,  -11937,  -16213,  -15820,    6581},
+{  -3155,   24796,    2733,   -1257,    -875,   -1597},
+{ -20469,   11094,   24071,   -8987,   14136,    2220},
+{ -14106,   11959,  -22495,    4135,   -1055,   -5420},
+{    801,   -2655,      60,   -5324,    -790,    5937},
+{  -7372,   -1764,  -22433,  -26060,   21707,    4178},
+{  -5715,   -6648,  -14908,    1325,  -24044,    1493},
+{  -6024,  -12488,   23930,    2950,    1601,    1173},
+{  19067,   17630,   17929,  -10654,   10928,   -4958},
+{   3231,   -3284,   27336,    4174,   -1683,     497},
+};
+
+const int16_t (*ff_vq_hebap[8])[6] = {
+    NULL,
+    ff_vq_hebap1,
+    ff_vq_hebap2,
+    ff_vq_hebap3,
+    ff_vq_hebap4,
+    ff_vq_hebap5,
+    ff_vq_hebap6,
+    ff_vq_hebap7,
+};
+
+/**
+ * Table E2.14 Frame Exponent Strategy Combinations
+ */
+const uint8_t ff_eac3_frm_expstr[32][6] = {
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D15,  EXP_REUSE,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE,    EXP_D45},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D25,  EXP_REUSE},
+{    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45,    EXP_D45},
+};
+
+/**
+ * Table E2.16 Default Coupling Banding Structure
+ */
+const uint8_t ff_eac3_defcplbndstrc[18] =
+{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1 };
+
+/**
+ * Table E2.15 Default Spectral Extension Banding Structure
+ */
+const uint8_t ff_eac3_defspxbndstrc[17] =
+{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};
+
+/**
+ * Table E2.17 Default Enhanced Coupling Banding Structure
+ */
+
+const uint8_t ff_eac3_defecplbndstrc[22] =
+{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1};
+
+
+/**
+ * Table E3.14 Spectral Extension Attenuation Table
+ */
+const float ff_eac3_spxattentab[32][3] = {
+    {0.954841604, 0.911722489, 0.870550563},
+    {0.911722489, 0.831237896, 0.757858283},
+    {0.870550563, 0.757858283, 0.659753955},
+    {0.831237896, 0.690956440, 0.574349177},
+    {0.793700526, 0.629960525, 0.500000000},
+    {0.757858283, 0.574349177, 0.435275282},
+    {0.723634619, 0.523647061, 0.378929142},
+    {0.690956440, 0.477420802, 0.329876978},
+    {0.659753955, 0.435275282, 0.287174589},
+    {0.629960525, 0.396850263, 0.250000000},
+    {0.601512518, 0.361817309, 0.217637641},
+    {0.574349177, 0.329876978, 0.189464571},
+    {0.548412490, 0.300756259, 0.164938489},
+    {0.523647061, 0.274206245, 0.143587294},
+    {0.500000000, 0.250000000, 0.125000000},
+    {0.477420802, 0.227930622, 0.108818820},
+    {0.455861244, 0.207809474, 0.094732285},
+    {0.435275282, 0.189464571, 0.082469244},
+    {0.415618948, 0.172739110, 0.071793647},
+    {0.396850263, 0.157490131, 0.062500000},
+    {0.378929142, 0.143587294, 0.054409410},
+    {0.361817309, 0.130911765, 0.047366143},
+    {0.345478220, 0.119355200, 0.041234622},
+    {0.329876978, 0.108818820, 0.035896824},
+    {0.314980262, 0.099212566, 0.031250000},
+    {0.300756259, 0.090454327, 0.027204705},
+    {0.287174589, 0.082469244, 0.023683071},
+    {0.274206245, 0.075189065, 0.020617311},
+    {0.261823531, 0.068551561, 0.017948412},
+    {0.250000000, 0.062500000, 0.015625000},
+    {0.238710401, 0.056982656, 0.013602353},
+    {0.227930622, 0.051952369, 0.011841536}
+};
+
+/**
+ * Table of bin locations for rematrixing bands
+ * reference: Section 7.5.2 Rematrixing : Frequency Band Definitions
+ */
+const uint8_t ff_ac3_rematrix_band_tbl[5] = { 13, 25, 37, 61, 253 };
+

--- libavcodec/ac3tab.h    2007-09-14 00:02:17.000000000 +0200
+++ libavcodec/ac3tab.h       2007-09-14 00:03:58.000000000 +0200
@@ -31,6 +31,7 @@
 extern const int16_t  ff_ac3_window[256];
 extern const uint8_t  ff_ac3_latab[260];
 extern const uint16_t ff_ac3_hth[50][3];
+extern const uint8_t  ff_ac3_hebaptab[64];
 extern const uint8_t  ff_ac3_baptab[64];
 extern const uint8_t  ff_sdecaytab[4];
 extern const uint8_t  ff_fdecaytab[4];
@@ -39,5 +40,27 @@
 extern const int16_t  ff_floortab[8];
 extern const uint16_t ff_fgaintab[8];
 extern const uint8_t  ff_ac3_bndsz[50];
+extern const uint8_t  ff_qntztab[16];
+extern const uint8_t ff_nfchans_tbl[8];
+extern const uint8_t ff_eac3_blocks[4];
+extern const uint8_t ff_bits_vs_hebap[20];
+extern const int16_t ff_eac3_gaq_remap[12][2][3][2];
+extern const uint8_t ff_gaq_gk[4][3];
+
+extern const int16_t ff_vq_hebap1[4][6];
+extern const int16_t ff_vq_hebap2[8][6];
+extern const int16_t ff_vq_hebap3[16][6];
+extern const int16_t ff_vq_hebap4[32][6];
+extern const int16_t ff_vq_hebap5[128][6];
+extern const int16_t ff_vq_hebap6[256][6];
+extern const int16_t ff_vq_hebap7[512][6];
+extern const int16_t (*ff_vq_hebap[8])[6];
+extern const uint8_t ff_eac3_frm_expstr[32][6];
+extern const uint8_t ff_eac3_defcplbndstrc[18];
+extern const uint8_t ff_eac3_defspxbndstrc[17];
+extern const uint8_t ff_eac3_defecplbndstrc[22];
+extern const float   ff_eac3_spxattentab[32][3];
+
+extern const uint8_t ff_ac3_rematrix_band_tbl[5];

 #endif /* AC3TAB_H */


--- libavcodec/eac3dec.c	2007-09-26 18:31:15.000000000 +0200
+++ libavcodec/eac3dec.c	2007-09-26 18:23:27.000000000 +0200
@@ -0,0 +1,1463 @@
+/*
+ * EAC3 decoder
+ * Copyright (c) 2007 Bartlomiej Wolowiec <bartek.wolowiec@gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "eac3.h"
+#include "ac3dec.h"
+#include "ac3.h"
+
+/**
+ * Table for default stereo downmixing coefficients
+ * reference: Section 7.8.2 Downmixing Into Two Channels
+ */
+static const uint8_t eac3_default_coeffs[8][5][2] = {
+    { { 2, 7 }, { 7, 2 },                               },
+    { { 4, 4 },                                         },
+    { { 2, 7 }, { 7, 2 },                               },
+    { { 2, 7 }, { 5, 5 }, { 7, 2 },                     },
+    { { 2, 7 }, { 7, 2 }, { 6, 6 },                     },
+    { { 2, 7 }, { 5, 5 }, { 7, 2 }, { 8, 8 },           },
+    { { 2, 7 }, { 7, 2 }, { 6, 7 }, { 7, 6 },           },
+    { { 2, 7 }, { 5, 5 }, { 7, 2 }, { 6, 7 }, { 7, 6 }, },
+};
+
+static const float mixlevels[9] = {
+    LEVEL_PLUS_3DB,
+    LEVEL_PLUS_1POINT5DB,
+    LEVEL_ONE,
+    LEVEL_MINUS_1POINT5DB,
+    LEVEL_MINUS_3DB,
+    LEVEL_MINUS_4POINT5DB,
+    LEVEL_MINUS_6DB,
+    LEVEL_ZERO,
+    LEVEL_MINUS_9DB
+};
+
+static void log_missing_feature(AVCodecContext *avctx, const char *log){
+    av_log(avctx, AV_LOG_ERROR, "%s is not implemented. If you want to help, "
+            "update your FFmpeg version to the newest one from SVN. If the "
+            "problem still occurs, it means that your file has extension "
+            "which has not been tested due to a lack of samples exhibiting "
+            "this feature. Upload a sample of the audio from this file to "
+            "ftp://upload.mplayerhq.hu/incoming and contact the ffmpeg-devel "
+            "mailing list.\n", log);
+}
+
+static void uncouple_channels(EAC3Context *s){
+    int i, j, ch, bnd, subbnd;
+
+    subbnd = s->cplbegf+1;
+    i = s->strtmant[CPL_CH];
+    for (bnd = 0; bnd < s->ncplbnd; bnd++) {
+        do {
+            for (j = 0; j < 12; j++) {
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    if (s->chincpl[ch]) {
+                        s->transform_coeffs[ch][i] =
+                            s->transform_coeffs[CPL_CH][i] *
+                            s->cplco[ch][bnd] * 8.0f;
+                    }
+                }
+                i++;
+            }
+        } while(s->cplbndstrc[subbnd++] && subbnd<=s->cplendf);
+    }
+}
+
+static void spectral_extension(EAC3Context *s){
+    //Now turned off, because there are no samples for testing it.
+#if 0
+    int copystartmant, copyendmant, copyindex, insertindex;
+    int wrapflag[18];
+    int bandsize, bnd, bin, spxmant, filtbin, ch;
+    float nratio, accum, nscale, sscale, spxcotemp;
+    float noffset[AC3_MAX_CHANNELS], nblendfact[AC3_MAX_CHANNELS][18], sblendfact[AC3_MAX_CHANNELS][18];
+    float rmsenergy[AC3_MAX_CHANNELS][18];
+
+    //XXX spxbandtable[bnd] = 25 + 12 * bnd ?
+
+    copystartmant = spxbandtable[s->spxstrtf];
+    copyendmant = spxbandtable[s->spxbegf];
+
+    for (ch = 1; ch <= s->nfchans; ch++) {
+        if (!s->chinspx[ch])
+            continue;
+
+        copyindex = copystartmant;
+        insertindex = copyendmant;
+
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            bandsize = s->spxbndsztab[bnd];
+            if ((copyindex + bandsize) > copyendmant) {
+                copyindex = copystartmant;
+                wrapflag[bnd] = 1;
+            } else
+                wrapflag[bnd] = 0;
+            for (bin = 0; bin < bandsize; bin++){
+                if (copyindex == copyendmant)
+                    copyindex = copystartmant;
+                s->transform_coeffs[ch][insertindex++] = s->transform_coeffs[ch][copyindex++];
+            }
+        }
+
+        noffset[ch] = s->spxblnd[ch] / 32.0;
+        spxmant = spxbandtable[s->spxbegf];
+        if (s->spxcoe[ch]) {
+            for (bnd = 0; bnd < s->nspxbnds; bnd++){
+                bandsize = s->spxbndsztab[bnd];
+                nratio = ((spxmant + 0.5*bandsize) / spxbandtable[s->spxendf]) - noffset[ch];
+                if (nratio < 0.0)
+                    nratio = 0.0;
+                else
+                    if (nratio > 1.0)
+                        nratio = 1.0;
+                nblendfact[ch][bnd] = sqrt(nratio);
+                sblendfact[ch][bnd] = sqrt(1 - nratio);
+                spxmant += bandsize;
+            }
+        }
+
+        spxmant = spxbandtable[s->spxbegf];
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            bandsize = s->spxbndsztab[bnd];
+            accum = 0;
+            for (bin = 0; bin < bandsize; bin++){
+                accum += (s->transform_coeffs[ch][spxmant] * s->transform_coeffs[ch][spxmant]);
+                spxmant++;
+            }
+            rmsenergy[ch][bnd] = sqrt(accum / bandsize);
+        }
+
+        if (s->chinspxatten[ch]) {
+            /* apply notch filter at baseband / extension region border */
+            filtbin = spxbandtable[s->spxbegf] - 2;
+            for (bin = 0; bin < 3; bin++){
+                s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                filtbin++;
+            }
+            for (bin = 1; bin >= 0; bin--){
+                s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                filtbin++;
+            }
+            filtbin += s->spxbndsztab[0];
+            /* apply notch at all other wrap points */
+            for (bnd = 1; bnd < s->nspxbnds; bnd++){
+                if (wrapflag[bnd]) {
+                    filtbin = filtbin - 5;
+                    for (bin = 0; bin < 3; bin++){
+                        s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                        filtbin++;
+                    }
+                    for (bin = 1; bin >= 0; bin--){
+                        s->transform_coeffs[ch][filtbin] *= ff_eac3_spxattentab[s->spxattencod[ch]][bin];
+                        filtbin++;
+                    }
+                }
+                filtbin += s->spxbndsztab[bnd];
+            }
+        }
+
+        spxmant = spxbandtable[s->spxbegf];
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            nscale = rmsenergy[ch][bnd] * nblendfact[ch][bnd];
+            sscale = sblendfact[ch][bnd];
+            for (bin = 0; bin < s->spxbndsztab[bnd]; bin++){
+                //TODO generate noise()
+                s->transform_coeffs[ch][spxmant] =
+                    s->transform_coeffs[ch][spxmant] * sscale + noise() * nscale;
+                spxmant++;
+            }
+        }
+
+        spxmant = spxbandtable[s->spxbegf];
+        for (bnd = 0; bnd < s->nspxbnds; bnd++){
+            spxcotemp = s->spxco[ch][bnd];
+            for (bin = 0; bin < s->spxbndsztab[bnd]; bin++){
+                s->transform_coeffs[ch][spxmant] *= spxcotemp * 32;
+                spxmant++;
+            }
+        }
+    }
+#endif
+}
+
+static void get_transform_coeffs_aht_ch(GetBitContext *gbc, EAC3Context *s, int ch){
+    int endbap, bin, n, m;
+    int bg, g, bits, pre_chmant, remap, chgaqsections, chgaqmod;
+    float mant;
+
+    chgaqmod = get_bits(gbc, 2);
+
+    endbap = chgaqmod<2?12:17;
+
+    chgaqsections = 0;
+    for (bin = 0; bin < s->endmant[ch]; bin++) {
+        if (s->hebap[ch][bin] > 7 && s->hebap[ch][bin] < endbap)
+            chgaqsections++;
+    }
+
+    if (chgaqmod == EAC3_GAQ_12 || chgaqmod == EAC3_GAQ_14) {
+        for (n = 0; n < chgaqsections; n++) {
+            s->chgaqgain[n] = get_bits1(gbc);
+        }
+    } else {
+        if (chgaqmod == EAC3_GAQ_124) {
+            int grpgain;
+            chgaqsections = (chgaqsections+2)/3;
+            for (n = 0; n < chgaqsections; n++) {
+                grpgain = get_bits(gbc, 5);
+                s->chgaqgain[3*n]   = grpgain/9;
+                s->chgaqgain[3*n+1] = (grpgain%9)/3;
+                s->chgaqgain[3*n+2] = grpgain%3;
+            }
+        }
+    }
+
+    m=0;
+    for (bin = s->strtmant[ch]; bin < s->endmant[ch]; bin++) {
+        if (s->hebap[ch][bin] > 7) {
+            // GAQ (E3.3.4.2)
+            // XXX what about gaqmod = 0 ?
+            // difference between Gk=1 and gaqmod=0 ?
+            if (s->hebap[ch][bin] < endbap) {
+                // hebap in active range
+                // Gk = 1<<bg
+                bg = ff_gaq_gk[chgaqmod][s->chgaqgain[m++]];
+            } else {
+                bg = 0;
+            }
+            bits = ff_bits_vs_hebap[s->hebap[ch][bin]];
+
+            for (n = 0; n < 6; n++) {
+                // pre_chmant[n][ch][bin]
+                pre_chmant = get_sbits(gbc, bits-bg);
+                if (bg && pre_chmant == -(1 << (bits - bg - 1))) {
+                    // large mantissa
+                    pre_chmant = get_sbits(gbc, bits - ((bg==1)?1:0));
+                    if (bg == 1)
+                        //Gk = 2
+                        mant = (float)pre_chmant/((1<<(bits-1))-1);
+                    else
+                        //Gk = 4
+                        mant = (float)pre_chmant*3.0f/((1<<(bits+1))-2);
+
+                    g = 0;
+                    remap = 1;
+                } else {
+                    // small mantissa
+                    if (bg)
+                        //Gk = 2 or 4
+                        mant = (float)pre_chmant/((1<<(bits-1))-1);
+                    else
+                        //Gk = 1
+                        mant = (float)pre_chmant*2.0f/((1<<bits)-1); ///XXX
+
+                    g = bg;
+                    remap = (!bg) && (s->hebap[ch][bin] < endbap);
+                }
+
+                //TODO when remap needed ?
+                if (remap) {
+                    mant = (float)
+                        (ff_eac3_gaq_remap[s->hebap[ch][bin]-8][0][g][0]/32768.0f + 1.0f)
+                        * mant / (1<<g) +
+                        (ff_eac3_gaq_remap[s->hebap[ch][bin]-8][mant<0][g][1]) / 32768.0f;
+                }
+                s->pre_chmant[n][ch][bin] = mant;
+            }
+        } else {
+            // hebap = 0 or VQ
+            if (s->hebap[ch][bin]) {
+                pre_chmant = get_bits(gbc, ff_bits_vs_hebap[s->hebap[ch][bin]]);
+                for (n = 0; n < 6; n++) {
+                    s->pre_chmant[n][ch][bin] =
+                        ff_vq_hebap[s->hebap[ch][bin]][pre_chmant][n] / 32768.0f;
+                }
+            } else {
+                for (n = 0; n < 6; n++) {
+                    s->pre_chmant[n][ch][bin] = 0;
+                }
+            }
+        }
+    }
+}
+
+static void idct_transform_coeffs_ch(EAC3Context *s, int ch, int blk){
+    // TODO fast IDCT
+    int bin, i;
+    float tmp;
+    for (bin = s->strtmant[ch]; bin < s->endmant[ch]; bin++) {
+        tmp = 0;
+        for (i = 0; i < 6; i++) {
+            tmp += (i?sqrt(2):1) * s->pre_chmant[i][ch][bin] * cos(M_PI*i*(2*blk + 1)/12);
+        }
+        s->transform_coeffs[ch][bin] = tmp * ff_ac3_scale_factors[s->dexps[ch][bin]];
+    }
+}
+
+static void get_eac3_transform_coeffs_ch(GetBitContext *gbc, EAC3Context *s, int blk,
+        int ch, mant_groups *m){
+    if (s->chahtinu[ch] == 0) {
+        ff_ac3_get_transform_coeffs_ch(m, gbc, s->dexps[ch], s->bap[ch],
+                s->transform_coeffs[ch], s->strtmant[ch], s->endmant[ch],
+                &s->dith_state);
+    } else {
+        if (s->chahtinu[ch] == 1) {
+            get_transform_coeffs_aht_ch(gbc, s, ch);
+            s->chahtinu[ch] = -1; /* AHT info for this frame has been read - do not read again */
+        }
+    }
+    if (s->chahtinu[ch] != 0) {
+        idct_transform_coeffs_ch(s, ch, blk);
+    }
+}
+
+static int parse_bsi(GetBitContext *gbc, EAC3Context *s){
+    int i, blk;
+
+    s->strmtyp = get_bits(gbc, 2);
+    if (s->strmtyp) {
+        log_missing_feature(s->avctx, "Dependent substream");
+        return -1;
+    }
+    s->substreamid = get_bits(gbc, 3);
+    s->frmsiz = get_bits(gbc, 11);
+    s->fscod = get_bits(gbc, 2);
+    if (s->fscod == 3) {
+        log_missing_feature(s->avctx, "Reduced Sampling Rates");
+        return -1;
+#if 0
+        s->fscod2 = get_bits(gbc, 2);
+        s->numblkscod = 3; /* six blocks per frame */
+#endif
+    } else {
+        s->numblkscod = get_bits(gbc, 2);
+    }
+    s->acmod = get_bits(gbc, 3);
+    s->lfeon = get_bits1(gbc);
+
+    // calculate number of channels
+    s->nfchans = ff_ac3_channels[s->acmod];
+    s->num_channels = s->nfchans;
+    s->lfe_channel = s->num_channels+1;
+    if (s->lfeon) {
+        s->strtmant[s->lfe_channel] = 0;
+        s->endmant [s->lfe_channel] = 7;
+        s->nchgrps [s->lfe_channel] = 2;
+        s->chincpl [s->lfe_channel] = 0;
+        s->num_channels++;
+    }
+
+    s->bsid = get_bits(gbc, 5);
+    if (s->bsid < 11 || s->bsid > 16) {
+        av_log(s->avctx, AV_LOG_ERROR, "bsid should be between 11 and 16\n");
+        return -1;
+    }
+
+    for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+        s->dialnorm[i] = ff_ac3_dialnorm_tbl[get_bits(gbc, 5)];
+        if (get_bits1(gbc)) {
+            skip_bits(gbc, 8); //skip Compression gain word
+        }
+    }
+    if (s->strmtyp == 1) {
+        /* if dependent stream */
+        if (get_bits1(gbc)) {
+            s->chanmap = get_bits(gbc, 16);
+        } else {
+            //TODO default channel map based on acmod and lfeon
+        }
+    }
+
+    /* set stereo downmixing coefficients
+       reference: Section 7.8.2 Downmixing Into Two Channels */
+    for (i = 0; i < s->nfchans; i++) {
+        s->downmix_coeffs[i][0] = mixlevels[eac3_default_coeffs[s->acmod][i][0]];
+        s->downmix_coeffs[i][1] = mixlevels[eac3_default_coeffs[s->acmod][i][1]];
+    }
+
+    s->mixmdate = get_bits1(gbc);
+    if (s->mixmdate) {
+        /* Mixing metadata */
+        if (s->acmod > 2) {
+            /* if more than 2 channels */
+            s->dmixmod = get_bits(gbc, 2);
+        }
+        if ((s->acmod & 1) && (s->acmod > 2)) {
+            /* if three front channels exist */
+            skip_bits(gbc, 3); //skip Lt/Rt center mix level
+            s->downmix_coeffs[1][0] = s->downmix_coeffs[1][1] = mixlevels[get_bits(gbc, 3)];
+        }
+        if (s->acmod & 4) {
+            /* if a surround channel exists */
+            float surmixlev;
+            skip_bits(gbc, 3); //skip Lt/Rt surround mix level
+            surmixlev = mixlevels[get_bits(gbc, 3)];
+            if (s->acmod & 2) {
+                //two surround channels
+                s->downmix_coeffs[s->acmod-4][0] = s->downmix_coeffs[s->acmod-3][1] =
+                    surmixlev;
+            } else {
+                s->downmix_coeffs[s->acmod-2][0] = s->downmix_coeffs[s->acmod-2][1] =
+                    surmixlev * LEVEL_MINUS_3DB;
+            }
+        }
+        if (s->lfeon) {
+            /* if the LFE channel exists */
+            s->lfemixlevcode = get_bits1(gbc);
+            if (s->lfemixlevcode) {
+                s->lfemixlevcod = get_bits(gbc, 5);
+            }
+        }
+        if (!s->strmtyp) {
+            /* if independent stream */
+            for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+                if (get_bits1(gbc)) {
+                    s->pgmscl[i] = get_bits(gbc, 6);
+                } else {
+                    //TODO program scale factor = 0dB
+                }
+            }
+            if (get_bits1(gbc)) {
+                s->extpgmscl = get_bits(gbc, 6);
+            }
+            s->mixdef = get_bits(gbc, 2);
+            if (s->mixdef == 1) {
+                /* mixing option 2 */
+                skip_bits(gbc, 5);
+            } else {
+                if (s->mixdef == 2) {
+                    /* mixing option 3 */
+                    skip_bits(gbc, 12);
+                } else {
+                    if (s->mixdef == 3) {
+                        /* mixing option 4 */
+                        s->mixdeflen = get_bits(gbc, 5);
+                        skip_bits(gbc, 8*(s->mixdeflen+2));
+                    }
+                }
+                if (s->acmod < 2) {
+                    /* if mono or dual mono source */
+                    for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+                        if (get_bits1(gbc)) {
+                            s->paninfo[i] = get_bits(gbc, 14);
+                        } else {
+                            //TODO default = center
+                        }
+                    }
+                }
+                s->frmmixcfginfoe = get_bits1(gbc);
+                if (s->frmmixcfginfoe) {
+                    /* mixing configuration information */
+                    if (!s->numblkscod) {
+                        s->blkmixcfginfo[0] = get_bits(gbc, 5);
+                    } else {
+                        for (blk = 0; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+                            if (get_bits1(gbc)) {
+                                s->blkmixcfginfo[blk] = get_bits(gbc, 5);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    s->infomdate = get_bits1(gbc);
+    if (s->infomdate) {
+        /* Informational metadata */
+        skip_bits(gbc, 3); //skip Bit stream mode
+        skip_bits(gbc, 2); //skip copyright bit and original bitstream bit
+        if (s->acmod == AC3_ACMOD_STEREO) { /* if in 2/0 mode */
+            skip_bits(gbc, 4); //skip Dolby surround and headphone mode
+        }
+        if (s->acmod >= 6) {
+            /* if both surround channels exist */
+            skip_bits(gbc, 2); //skip Dolby surround EX mode
+        }
+        for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+            if (get_bits1(gbc)) {
+                skip_bits(gbc, 8); //skip Mix level, Room type and A/D converter type
+            }
+        }
+        if (s->fscod < 3) {
+            /* if not half sample rate */
+            skip_bits1(gbc); //skip Source sample rate code
+        }
+    }
+    if ((!s->strmtyp) && (s->numblkscod != 3)) {
+        skip_bits1(gbc); //converter synchronization flag
+    }
+    if (s->strmtyp == 2) {
+        /* if bit stream converted from AC-3 */
+        if (s->numblkscod == 3 || get_bits1(gbc)) {
+            /* 6 blocks per frame */
+            skip_bits(gbc, 6); // skip Frame size code
+        }
+    }
+    if (get_bits1(gbc)) {
+        int addbsil = get_bits(gbc, 6);
+        for (i = 0; i < addbsil + 1; i++) {
+            skip_bits(gbc, 8); // Additional bit stream information
+        }
+    }
+
+    return 0;
+} /* end of bsi */
+
+static int parse_audfrm(GetBitContext *gbc, EAC3Context *s){
+    int blk, ch;
+
+    /* Audio frame exist flags and strategy data */
+    if (s->numblkscod == 3) {
+        /* six blocks per frame */
+        /* LUT-based exponent strategy syntax */
+        s->expstre = get_bits1(gbc);
+        s->ahte = get_bits1(gbc);
+    } else {
+        /* AC-3 style exponent strategy syntax */
+        s->expstre = 1;
+        s->ahte = 0;
+    }
+    s->snroffststr = get_bits(gbc, 2);
+    s->transproce = get_bits1(gbc);
+    s->blkswe = get_bits1(gbc);
+    if (!s->blkswe) {
+        for (ch = 1; ch <= s->nfchans; ch++)
+            s->blksw[ch] = 0;
+    }
+    s->dithflage = get_bits1(gbc);
+    if (!s->dithflage) {
+        for (ch = 1; ch <= s->nfchans; ch++)
+            s->dithflag[ch] = 1; /* dither on */
+    }
+    s->dithflag[CPL_CH] = s->dithflag[s->lfe_channel] = 0;
+
+    /* frame-based syntax flags */
+    s->bamode = get_bits1(gbc);
+    s->frmfgaincode = get_bits1(gbc);
+    s->dbaflde = get_bits1(gbc);
+    s->skipflde = get_bits1(gbc);
+    s->spxattene = get_bits1(gbc);
+    /* Coupling data */
+    if (s->acmod > 1) {
+        s->cplstre[0] = 1;
+        s->cplinu[0] = get_bits1(gbc);
+        s->ncplblks = s->cplinu[0];
+        for (blk = 1; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+            s->cplstre[blk] = get_bits1(gbc);
+
+            if (s->cplstre[blk]) {
+                s->cplinu[blk] = get_bits1(gbc);
+            } else {
+                s->cplinu[blk] = s->cplinu[blk-1];
+            }
+            s->ncplblks += s->cplinu[blk];
+        }
+    } else {
+        memset(s->cplinu, 0, sizeof(int) * ff_eac3_blocks[s->numblkscod]);
+        s->ncplblks = 0;
+    }
+
+    /* Exponent strategy data */
+    if (s->expstre) {
+        /* AC-3 style exponent strategy syntax */
+        for (blk = 0; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+            for (ch = !s->cplinu[blk]; ch <= s->nfchans; ch++) {
+                s->chexpstr[blk][ch] = get_bits(gbc, 2);
+            }
+        }
+    } else {
+        /* LUT-based exponent strategy syntax */
+        int frmchexpstr;
+        /* cplexpstr[blk] and chexpstr[blk][ch] derived from table lookups. see Table E2.14 */
+        for (ch = !((s->acmod > 1) && (s->ncplblks)); ch <= s->nfchans; ch++) {
+            frmchexpstr = get_bits(gbc, 5);
+            for (blk = 0; blk < 6; blk++) {
+                s->chexpstr[blk][ch] = ff_eac3_frm_expstr[frmchexpstr][blk];
+            }
+        }
+    }
+    /* LFE exponent strategy */
+    if (s->lfeon) {
+        for (blk = 0; blk < ff_eac3_blocks[s->numblkscod]; blk++) {
+            s->chexpstr[blk][s->lfe_channel] = get_bits1(gbc);
+        }
+    }
+    /* Converter exponent strategy data */
+    if (!s->strmtyp) {
+        if (s->numblkscod == 3 || get_bits1(gbc)) {
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                skip_bits(gbc, 5); //skip Converter channel exponent strategy
+            }
+        }
+    }
+    /* AHT data */
+    if (s->ahte) {
+        /* AHT is only available in 6 block mode (numblkscod ==3) */
+        /* coupling can use AHT only when coupling in use for all blocks */
+        /* ncplregs derived from cplstre and cplexpstr - see Section E3.3.2 */
+        int nchregs;
+        s->chahtinu[CPL_CH]=0;
+        for (ch = (s->ncplblks != 6); ch <= s->num_channels; ch++) {
+            nchregs = 0;
+            for (blk = 0; blk < 6; blk++)
+                nchregs += (s->chexpstr[blk][ch] != EXP_REUSE);
+            s->chahtinu[ch] = (nchregs == 1) && get_bits1(gbc);
+        }
+    } else {
+        for (ch = 0; ch <= s->num_channels; ch++)
+            s->chahtinu[ch] = 0;
+    }
+    /* Audio frame SNR offset data */
+    if (!s->snroffststr) {
+        int csnroffst = (get_bits(gbc, 6) - 15) << 4;
+        int snroffst = (csnroffst + get_bits(gbc, 4)) << 2;
+        for (ch = 0; ch <= s->num_channels; ch++)
+            s->snroffst[ch] = snroffst;
+    }
+    /* Audio frame transient pre-noise processing data */
+    if (s->transproce) {
+        av_log(s->avctx, AV_LOG_ERROR, "transient pre-noise processing NOT IMPLEMENTED\n");
+//        return -1;
+//#if 0
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->chintransproc[ch] = get_bits1(gbc);
+            if (s->chintransproc[ch]) {
+                s->transprocloc[ch] = get_bits(gbc, 10);
+                s->transproclen[ch] = get_bits(gbc, 8);
+            }
+        }
+//#endif
+    }
+    /* Spectral extension attenuation data */
+    if (s->spxattene) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->chinspxatten[ch] = get_bits1(gbc);
+            if (s->chinspxatten[ch]) {
+                s->spxattencod[ch] = get_bits(gbc, 5);
+            }
+        }
+    } else {
+        for (ch = 1; ch <= s->nfchans; ch++)
+            s->chinspxatten[ch]=0;
+    }
+    /* Block start information */
+    if (s->numblkscod && get_bits1(gbc)) {
+        /* nblkstrtbits determined from frmsiz (see Section E2.3.2.27) */
+        // nblkstrtbits = (numblks - 1) * (4 + ceiling (log2 (words_per_frame)))
+        // where numblks is derived from the numblkscod in Table E2.9
+        // words_per_frame = frmsiz + 1
+        int nblkstrtbits = (ff_eac3_blocks[s->numblkscod]-1) * (4 + (av_log2(s->frmsiz-1)+1) );
+        av_log(s->avctx, AV_LOG_INFO, "nblkstrtbits = %i\n", nblkstrtbits);
+        s->blkstrtinfo = get_bits(gbc, nblkstrtbits);
+    }
+    /* Syntax state initialization */
+    for (ch = 1; ch <= s->nfchans; ch++) {
+        s->firstspxcos[ch] = 1;
+        s->firstcplcos[ch] = 1;
+    }
+    s->firstcplleak = 1;
+
+    return 0;
+} /* end of audfrm */
+
+static int parse_audblk(GetBitContext *gbc, EAC3Context *s, const int blk){
+    //int grp, sbnd, n, bin;
+    int seg, bnd, ch, i, chbwcod, grpsize;
+    int got_cplchan;
+    mant_groups m;
+
+    m.b1ptr = m.b2ptr = m.b4ptr = 3;
+
+    /* Block switch and dither flags */
+    if (s->blkswe) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->blksw[ch] = get_bits1(gbc);
+        }
+    }
+    if (s->dithflage) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            s->dithflag[ch] = get_bits1(gbc);
+        }
+    }
+
+    /* Dynamic range control */
+    for (i = 0; i < (s->acmod ? 1 : 2); i++) {
+        if (get_bits1(gbc)) {
+            s->dynrng[i] = ff_ac3_dynrng_tbl[get_bits(gbc, 8)];
+        } else {
+            if (!blk) {
+                s->dynrng[i] = 1.0f;
+            }
+        }
+    }
+    /* Spectral extension strategy information */
+    if ((!blk) || get_bits1(gbc)) {
+        s->spxinu = get_bits1(gbc);
+        if (s->spxinu) {
+            log_missing_feature(s->avctx, "Spectral extension");
+            return -1;
+#if 0
+            if (s->acmod == AC3_ACMOD_MONO) {
+                s->chinspx[1] = 1;
+            } else {
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    s->chinspx[ch] = get_bits1(gbc);
+                }
+            }
+#if 0
+            {
+                int nspx=0;
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    nspx+=s->chinspx[ch];
+                }
+                if (!nspx)
+                    av_log(s->avctx, AV_LOG_INFO, "No channels in spectral extension\n");
+            }
+#endif
+            s->spxstrtf = get_bits(gbc, 2);
+            s->spxbegf = get_bits(gbc, 3);
+            s->spxendf = get_bits(gbc, 3);
+            if (s->spxbegf < 6) {
+                s->spxbegf += 2;
+            } else {
+                s->spxbegf = s->spxbegf * 2 - 3;
+            }
+            if (s->spxendf < 3) {
+                s->spxendf += 5;
+            } else {
+                s->spxendf = s->spxendf * 2 + 3;
+            }
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                if (s->chinspx[ch])
+                    s->endmant[ch] = 25 + 12 * s->spxbegf;
+            }
+            if (get_bits1(gbc)) {
+                for (bnd = s->spxbegf + 1; bnd < s->spxendf; bnd++) {
+                    s->spxbndstrc[bnd] = get_bits1(gbc);
+                }
+            } else {
+                if (!blk) {
+                    for (bnd = 0; bnd < 17; bnd++)
+                        s->spxbndstrc[bnd] = ff_eac3_defspxbndstrc[bnd];
+                }
+            }
+            // calculate number of spectral extension bands
+            s->nspxbnds = 1;
+            s->spxbndsztab[0] = 12;
+            for (bnd = s->spxbegf+1; bnd < s->spxendf; bnd ++){
+                if (!s->spxbndstrc[bnd]) {
+                    s->spxbndsztab[s->nspxbnds] = 12;
+                    s->nspxbnds++;
+                } else {
+                    s->spxbndsztab[s->nspxbnds - 1] += 12;
+                }
+            }
+#endif
+        } else {
+            /* !spxinu */
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                s->chinspx[ch] = 0;
+                s->firstspxcos[ch] = 1;
+            }
+        }
+    }
+
+    /* Spectral extension coordinates */
+    if (s->spxinu) {
+        for (ch = 1; ch <= s->nfchans; ch++) {
+            if (s->chinspx[ch]) {
+                if (s->firstspxcos[ch]) {
+                    s->spxcoe[ch] = 1;
+                    s->firstspxcos[ch] = 0;
+                } else {
+                    /* !firstspxcos[ch] */
+                    s->spxcoe[ch] = get_bits1(gbc);
+                }
+                if (!blk && !s->spxcoe[ch]) {
+                    av_log(s->avctx, AV_LOG_ERROR, "no spectral extension coordinates in first block\n");
+                    return -1;
+                }
+
+                if (s->spxcoe[ch]) {
+                    int spxcoexp, spxcomant, mstrspxco;
+                    s->spxblnd[ch] = get_bits(gbc, 5);
+                    mstrspxco = get_bits(gbc, 2);
+                    mstrspxco*=3;
+                    /* nspxbnds determined from spxbegf, spxendf, and spxbndstrc[ ] */
+                    for (bnd = 0; bnd < s->nspxbnds; bnd++) {
+                        spxcoexp = get_bits(gbc, 4);
+                        spxcomant = get_bits(gbc, 2);
+                        if (spxcoexp == 15)
+                            s->spxco[ch][bnd] = spxcomant / 4.0f;
+                        else
+                            s->spxco[ch][bnd] = (spxcomant+4) / 8.0f;
+                        s->spxco[ch][bnd] *= ff_ac3_scale_factors[spxcoexp + mstrspxco];
+                    }
+                }
+            } else {
+                /* !chinspx[ch] */
+                s->firstspxcos[ch] = 1;
+            }
+        }
+    }
+    /* Coupling strategy and enhanced coupling strategy information */
+    if (s->cplstre[blk]) {
+        if (s->cplinu[blk]) {
+            s->ecplinu = get_bits1(gbc);
+            if (s->acmod == AC3_ACMOD_STEREO) {
+                s->chincpl[1] = 1;
+                s->chincpl[2] = 1;
+            } else {
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    s->chincpl[ch] = get_bits1(gbc);
+                }
+            }
+            if (!s->ecplinu) {
+                /* standard coupling in use */
+                if (s->acmod == AC3_ACMOD_STEREO) { /* if in 2/0 mode */
+                    s->phsflginu = get_bits1(gbc);
+                }
+                s->cplbegf = get_bits(gbc, 4);
+                if (!s->spxinu) {
+                    /* if SPX not in use */
+                    s->cplendf = get_bits(gbc, 4);
+                    s->cplendf += 3;
+                } else {
+                    /* SPX in use */
+                    s->cplendf = s->spxbegf - 1;
+                }
+
+                s->strtmant[CPL_CH] = 37 + (12 * s->cplbegf);
+                s->endmant[CPL_CH] = 37 + (12 * s->cplendf);
+                if (s->strtmant[CPL_CH] > s->endmant[CPL_CH]) {
+                    av_log(s->avctx, AV_LOG_ERROR, "cplstrtmant > cplendmant [blk=%i]\n", blk);
+                    return -1;
+                }
+                for (ch = 1; ch <= s->nfchans; ch++) {
+                    if (s->chincpl[ch])
+                        s->endmant[ch] = s->strtmant[CPL_CH];
+                }
+                if (get_bits1(gbc)) {
+                    for (bnd = s->cplbegf + 1; bnd < s->cplendf; bnd++) {
+                        s->cplbndstrc[bnd] = get_bits1(gbc);
+                    }
+                } else {
+                    if (!blk) {
+                        for (bnd = 0; bnd < 18; bnd++)
+                            s->cplbndstrc[bnd] = ff_eac3_defcplbndstrc[bnd];
+                    }
+                }
+                s->ncplsubnd =  s->cplendf - s->cplbegf;
+                s->ncplbnd = s->ncplsubnd;
+                for (bnd = s->cplbegf + 1; bnd < s->cplendf; bnd++) {
+                    s->ncplbnd -= s->cplbndstrc[bnd];
+                }
+            } else {
+                /* enhanced coupling in use */
+                log_missing_feature(s->avctx, "Enhanced coupling");
+                return -1;
+#if 0
+                s->ecplbegf = get_bits(gbc, 4);
+                if (s->ecplbegf < 3) {
+                    s->ecpl_start_subbnd = s->ecplbegf * 2;
+                } else {
+                    if (s->ecplbegf < 13) {
+                        s->ecpl_start_subbnd = s->ecplbegf + 2;
+                    } else {
+                        s->ecpl_start_subbnd = s->ecplbegf * 2 - 10;
+                    }
+                }
+                if (!s->spxinu) {
+                    /* if SPX not in use */
+                    s->ecplendf = get_bits(gbc, 4);
+                    s->ecpl_end_subbnd = s->ecplendf + 7;
+                } else {
+                    /* SPX in use */
+                    if (s->spxbegf < 6) {
+                        s->ecpl_end_subbnd = s->spxbegf + 5;
+                    } else {
+                        s->ecpl_end_subbnd = s->spxbegf * 2;
+                    }
+                }
+                if (get_bits1(gbc)) {
+                    for (sbnd = FFMAX(9, s->ecpl_start_subbnd + 1);
+                            sbnd < s->ecpl_end_subbnd; sbnd++){
+                        s->ecplbndstrc[sbnd] = get_bits1(gbc);
+                    }
+                } else {
+                    if (!blk) {
+                        for (sbnd = 0; sbnd < 22; sbnd++)
+                            s->ecplbndstrc[sbnd] = ff_eac3_defecplbndstrc[sbnd];
+                    }
+                }
+                //necplbnd = ecpl_end_subbnd - ecpl_start_subbnd;
+                //necplbnd -= ecplbndstrc[ecpl_start_subbnd] + ... + ecplbndstrc[ecpl_end_subbnd -1]
+                s->necplbnd = s->ecpl_end_subbnd - s->ecpl_start_subbnd;
+                for (bnd = s->ecpl_start_subbnd; bnd < s->ecpl_end_subbnd; bnd++) {
+                    s->necplbnd -= s->ecplbndstrc[bnd];
+                }
+#endif
+            } /* ecplinu[blk] */
+        } else {
+            /* !cplinu[blk] */
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                s->chincpl[ch] = 0;
+                s->firstcplcos[ch] = 1;
+            }
+            s->firstcplleak = 1;
+            s->phsflginu = 0;
+            s->ecplinu = 0;
+        }
+    } /* cplstre[blk] */
+    /* Coupling coordinates */
+    if (s->cplinu[blk]) {
+        if (!s->ecplinu) {
+            /* standard coupling in use */
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                if (s->chincpl[ch]) {
+                    if (s->firstcplcos[ch]) {
+                        s->cplcoe[ch] = 1;
+                        s->firstcplcos[ch] = 0;
+                    } else {
+                        /* !firstcplcos[ch] */
+                        s->cplcoe[ch] = get_bits1(gbc);
+                    }
+                    if (s->cplcoe[ch]) {
+                        int cplcoexp, cplcomant, mstrcplco;
+                        mstrcplco = get_bits(gbc, 2);
+                        mstrcplco = 3 * mstrcplco;
+                        /* ncplbnd derived from cplbegf, cplendf, and cplbndstrc */
+                        for (bnd = 0; bnd < s->ncplbnd; bnd++) {
+                            cplcoexp = get_bits(gbc, 4);
+                            cplcomant = get_bits(gbc, 4);
+                            if (cplcoexp == 15)
+                                s->cplco[ch][bnd] = cplcomant / 16.0f;
+                            else
+                                s->cplco[ch][bnd] = (cplcomant + 16.0f) / 32.0f;
+                            s->cplco[ch][bnd] *=  ff_ac3_scale_factors[cplcoexp + mstrcplco];
+                        }
+                    } /* cplcoe[ch] */
+                    else {
+                        if (!blk) {
+                            av_log(s->avctx, AV_LOG_ERROR,  "no coupling coordinates in first block\n");
+                            return -1;
+                        }
+                    }
+                } else {
+                    /* ! chincpl[ch] */
+                    s->firstcplcos[ch] = 1;
+                }
+            } /* ch */
+            if ((s->acmod == AC3_ACMOD_STEREO) && s->phsflginu
+                    && (s->cplcoe[1] || s->cplcoe[2])) {
+                for (bnd = 0; bnd < s->ncplbnd; bnd++) {
+                    s->phsflg[bnd] = get_bits1(gbc);
+                }
+            }
+            s->nchgrps[CPL_CH] = (s->endmant[CPL_CH] - s->strtmant[CPL_CH]) /
+                (3 << (s->chexpstr[blk][CPL_CH] - 1));
+        } else {
+            /* enhanced coupling in use */
+            //TODO calc nchgrps[CPL_CH]
+#if 0
+            s->firstchincpl = -1;
+            s->ecplangleintrp = get_bits1(gbc);
+            for (ch = 1; ch <= s->nfchans; ch++) {
+                if (s->chincpl[ch]) {
+                    if (s->firstchincpl == -1) {
+                        s->firstchincpl = ch;
+                    }
+                    if (s->firstcplcos[ch]) {
+                        s->ecplparam1e[ch] = 1;
+                        if (ch > s->firstchincpl) {
+                            s->ecplparam2e[ch] = 1;
+                        } else {
+                            s->ecplparam2e[ch] = 0;
+                        }
+                        s->firstcplcos[ch] = 0;
+                    } else {
+                        /* !firstcplcos[ch] */
+                        s->ecplparam1e[ch] = get_bits1(gbc);
+                        if (ch > s->firstchincpl) {
+                            s->ecplparam2e[ch] = get_bits1(gbc);
+                        } else {
+                            s->ecplparam2e[ch] = 0;
+                        }
+                    }
+                    if (s->ecplparam1e[ch]) {
+                        /* necplbnd derived from ecpl_start_subbnd, ecpl_end_subbnd, and ecplbndstrc */
+                        for (bnd = 0; bnd < s->necplbnd; bnd++) {
+                            s->ecplamp[ch][bnd] = get_bits(gbc, 5);
+                        }
+                    }
+                    if (s->ecplparam2e[ch]) {
+                        /* necplbnd derived from ecpl_start_subbnd, ecpl_end_subbnd, and ecplbndstrc */
+                        for (bnd = 0; bnd < s->necplbnd; bnd++) {
+                            s->ecplangle[ch][bnd] = get_bits(gbc, 6);
+                            s->ecplchaos[ch][bnd] = get_bits(gbc, 3);
+                        }
+                    }
+                    if (ch > s->firstchincpl) {
+                        s->ecpltrans[ch] = get_bits1(gbc);
+                    }
+                } else {
+                    /* !chincpl[ch] */
+                    s->firstcplcos[ch] = 1;
+                }
+            } /* ch */
+#endif
+        } /* ecplinu[blk] */
+    } /* cplinu[blk] */
+    /* Rematrixing operation in the 2/0 mode */
+    if (s->acmod == AC3_ACMOD_STEREO) { /* if in 2/0 mode */
+        if (!blk || get_bits1(gbc)) {
+            /* nrematbnds determined from cplinu, ecplinu, spxinu, cplbegf, ecplbegf and spxbegf */
+            // TODO spx in one channel
+            int end = (s->cplinu[blk] || s->spxinu) ?
+                FFMIN(s->endmant[1], s->endmant[2]) : (ff_ac3_rematrix_band_tbl[4]-1);
+            for (bnd = 0; ff_ac3_rematrix_band_tbl[bnd] <= end; bnd++) {
+                s->rematflg[bnd] = get_bits1(gbc);
+            }
+            s->nrematbnds = bnd;
+        }
+    }
+    /* Channel bandwidth code */
+    for (ch = 1; ch <= s->nfchans; ch++) {
+        if (!blk && s->chexpstr[blk][ch] == EXP_REUSE) {
+            av_log(s->avctx, AV_LOG_ERROR,  "no channel exponent strategy in first block\n");
+            return -1;
+        }
+        if (s->chexpstr[blk][ch] != EXP_REUSE) {
+            grpsize = 3 << (s->chexpstr[blk][ch] - 1);
+            s->strtmant[ch] = 0;
+            if ((!s->chincpl[ch]) && (!s->chinspx[ch])) {
+                chbwcod = get_bits(gbc, 6);
+                if (chbwcod > 60) {
+                    av_log(s->avctx, AV_LOG_ERROR, "chbwcod > 60\n");
+                    return -1;
+                }
+                s->endmant[ch] = ((chbwcod + 12) * 3) + 37; /* (ch is not coupled) */
+            }
+            grpsize = 3 << (s->chexpstr[blk][ch] - 1);
+            s->nchgrps[ch] = (s->endmant[ch] + grpsize - 4) / grpsize;
+        }
+    }
+    /* Exponents */
+    for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++) {
+        if (s->chexpstr[blk][ch] != EXP_REUSE) {
+            s->dexps[ch][0] = get_bits(gbc, 4) << !ch;
+            ff_ac3_decode_exponents(gbc, s->chexpstr[blk][ch], s->nchgrps[ch],
+                    s->dexps[ch][0], s->dexps[ch]+s->strtmant[ch]+!!ch);
+            if (ch != CPL_CH && ch != s->lfe_channel)
+                skip_bits(gbc, 2); /* skip gainrng */
+        }
+    }
+
+    /* Bit-allocation parametric information */
+    if (s->bamode) {
+        if (get_bits1(gbc)) {
+            s->bit_alloc_params.sdecay = ff_sdecaytab[get_bits(gbc, 2)];   /* Table 7.6 */
+            s->bit_alloc_params.fdecay = ff_fdecaytab[get_bits(gbc, 2)];   /* Table 7.7 */
+            s->bit_alloc_params.sgain  = ff_sgaintab [get_bits(gbc, 2)];   /* Table 7.8 */
+            s->bit_alloc_params.dbknee = ff_dbkneetab[get_bits(gbc, 2)];   /* Table 7.9 */
+            s->bit_alloc_params.floor  = ff_floortab [get_bits(gbc, 3)];   /* Table 7.10 */
+        } else {
+            if (!blk) {
+                av_log(s->avctx, AV_LOG_ERROR, "no bit allocation information in first block\n");
+                return -1;
+            }
+        }
+    } else {
+        s->bit_alloc_params.sdecay = ff_sdecaytab[2];   /* Table 7.6 */
+        s->bit_alloc_params.fdecay = ff_fdecaytab[1];   /* Table 7.7 */
+        s->bit_alloc_params.sgain  = ff_sgaintab[1];    /* Table 7.8 */
+        s->bit_alloc_params.dbknee = ff_dbkneetab[2];   /* Table 7.9 */
+        s->bit_alloc_params.floor  = ff_floortab[7];    /* Table 7.10 */
+    }
+
+    if (s->snroffststr) {
+        av_log(s->avctx, AV_LOG_INFO, "NOT TESTED\n");
+        if (!blk || get_bits1(gbc)) {
+            int csnroffst = (get_bits(gbc, 6) - 15) << 4;
+            if (s->snroffststr == 1) {
+                int snroffst = (csnroffst + get_bits(gbc, 4)) << 2;
+                for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+                    s->snroffst[ch] = snroffst;
+            } else {
+                if (s->snroffststr == 2) {
+                    for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+                        s->snroffst[ch] = (csnroffst + get_bits(gbc, 4)) << 2;
+                }
+            }
+        }
+    }
+
+    if (s->frmfgaincode && get_bits1(gbc)) {
+        for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+            s->fgain[ch] = ff_fgaintab[get_bits(gbc, 3)];
+    } else {
+        if (!blk) {
+            for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++)
+                s->fgain[ch] = ff_fgaintab[4];
+        }
+    }
+    if (!s->strmtyp) {
+        if (get_bits1(gbc)) {
+            skip_bits(gbc, 10); //Converter SNR offset
+        }
+    }
+    if (s->cplinu[blk]) {
+        if (s->firstcplleak) {
+            s->cplleake = 1;
+            s->firstcplleak = 0;
+        } else {
+            /* !firstcplleak */
+            s->cplleake = get_bits1(gbc);
+        }
+        if (s->cplleake) {
+            s->bit_alloc_params.cplfleak = get_bits(gbc, 3);
+            s->bit_alloc_params.cplsleak = get_bits(gbc, 3);
+        }
+    }
+    /* Delta bit allocation information */
+    if (s->dbaflde && get_bits1(gbc)) {
+        for (ch = !s->cplinu[blk]; ch <= s->nfchans; ch++) {
+            s->deltbae[ch] = get_bits(gbc, 2);
+        }
+        for (ch = !s->cplinu[blk]; ch <= s->nfchans; ch++) {
+            if (s->deltbae[ch] == DBA_NEW) {
+                s->deltnseg[ch] = get_bits(gbc, 3);
+                for (seg = 0; seg <= s->deltnseg[ch]; seg++) {
+                    s->deltoffst[ch][seg] = get_bits(gbc, 5);
+                    s->deltlen[ch][seg] = get_bits(gbc, 4);
+                    s->deltba[ch][seg] = get_bits(gbc, 3);
+                }
+            }
+        }
+    } else {
+        if (!blk) {
+            for (ch = 0; ch <= s->num_channels; ch++) {
+                s->deltbae[ch] = DBA_NONE;
+            }
+        }
+    }
+
+    /* Inclusion of unused dummy data */
+    if (s->skipflde) {
+        if (get_bits1(gbc)) {
+            int skipl = get_bits(gbc, 9);
+            while(skipl--) skip_bits(gbc, 8);
+        }
+    }
+
+    /* run bit allocation */
+    for (ch = !s->cplinu[blk]; ch <= s->num_channels; ch++) {
+        int start=0, end=0;
+        start = s->strtmant[ch];
+        end = s->endmant[ch];
+
+        ff_ac3_bit_alloc_calc_psd((int8_t *)s->dexps[ch], start, end,
+                s->psd[ch], s->bndpsd[ch]);
+
+        s->bit_alloc_params.fscod = s->fscod;
+        s->bit_alloc_params.halfratecod = 0;
+
+        ff_ac3_bit_alloc_calc_mask(&s->bit_alloc_params,
+                s->bndpsd[ch], start, end, s->fgain[ch],
+                (ch == s->lfe_channel),
+                s->deltbae[ch], s->deltnseg[ch],
+                s->deltoffst[ch], s->deltlen[ch],
+                s->deltba[ch], s->mask[ch]);
+
+        if (s->chahtinu[ch] == 0)
+            ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch], start, end,
+                    s->snroffst[ch], s->bit_alloc_params.floor, ff_ac3_baptab,
+                    s->bap[ch]);
+        else
+            if (s->chahtinu[ch] == 1)
+                ff_ac3_bit_alloc_calc_bap(s->mask[ch], s->psd[ch], start, end,
+                        s->snroffst[ch], s->bit_alloc_params.floor, ff_ac3_hebaptab,
+                        s->hebap[ch]);
+    }
+
+    got_cplchan = 0;
+
+    // TODO only for debug
+    for (ch = 0; ch <= s->num_channels; ch++)
+        memset(s->transform_coeffs[ch], 0, 256*sizeof(float));
+
+    /* Quantized mantissa values */
+    for (ch = 1; ch <= s->num_channels; ch++) {
+        get_eac3_transform_coeffs_ch(gbc, s, blk, ch, &m);
+        if (s->cplinu[blk] && s->chincpl[ch] && !got_cplchan) {
+            get_eac3_transform_coeffs_ch(gbc, s, blk, CPL_CH, &m);
+            got_cplchan = 1;
+        }
+    }
+
+    if (s->cplinu[blk])
+        uncouple_channels(s);
+
+    //apply spectral extension
+    if (s->spxinu)
+        spectral_extension(s);
+
+    return 0;
+}
+
+/**
+ * Performs Inverse MDCT transform
+ */
+static void do_imdct(EAC3Context *ctx)
+{
+    int ch;
+
+    for (ch = 1; ch <= ctx->nfchans + ctx->lfeon; ch++) {
+        if (ctx->blksw[ch]) {
+            /* 256-point IMDCT */
+            ff_ac3_do_imdct_256(ctx->tmp_output, ctx->transform_coeffs[ch],
+                    &ctx->imdct_256, ctx->tmp_imdct);
+        } else {
+            /* 512-point IMDCT */
+            ctx->imdct_512.fft.imdct_calc(&ctx->imdct_512, ctx->tmp_output,
+                    ctx->transform_coeffs[ch],
+                    ctx->tmp_imdct);
+        }
+        /* apply window function, overlap/add output, save delay */
+        ctx->dsp.vector_fmul_add_add(ctx->output[ch-1], ctx->tmp_output,
+                ctx->window, ctx->delay[ch-1], 0,
+                AC3_BLOCK_SIZE, 1);
+        ctx->dsp.vector_fmul_reverse(ctx->delay[ch-1], ctx->tmp_output+256,
+                ctx->window, AC3_BLOCK_SIZE);
+    }
+}
+
+static int eac3_decode_frame(AVCodecContext *avctx, void *data, int *data_size,
+        uint8_t *buf, int buf_size){
+    int16_t *out_samples = (int16_t *)data;
+    EAC3Context *c = (EAC3Context *)avctx->priv_data;
+    int k, i, blk, ch;
+    GetBitContext gbc;
+
+    *data_size = 0;
+    c->gbc = &gbc;
+    c->syncword = 0;
+    init_get_bits(&gbc, buf, buf_size*8);
+    c->syncword = get_bits(&gbc, 16);
+
+    if (c->syncword != 0x0B77)
+        return -1;
+
+    if (parse_bsi(&gbc, c) || parse_audfrm(&gbc, c))
+        return -1;
+
+    if (c->fscod == 3) {
+        avctx->sample_rate = ff_ac3_freqs[c->fscod2] / 2;
+    } else {
+        avctx->sample_rate = ff_ac3_freqs[c->fscod];
+    }
+
+    avctx->bit_rate = (c->frmsiz * (avctx->sample_rate) * 16 / ( ff_eac3_blocks[c->numblkscod] * 256)) / 1000;
+
+    /* channel config */
+    if (!avctx->request_channels) {
+        if (!avctx->channels)
+            avctx->channels = c->num_channels;
+    } else {
+        if (c->num_channels < avctx->request_channels) {
+            av_log(avctx, AV_LOG_ERROR, "Cannot upmix EAC3 from %d to %d channels.\n",
+                    c->num_channels, avctx->request_channels);
+            return -1;
+        } else {
+            if (avctx->request_channels > 2
+                    && avctx->request_channels != c->num_channels) {
+                av_log(avctx, AV_LOG_ERROR, "Cannot downmix EAC3 from %d to %d channels.\n",
+                        c->num_channels, avctx->request_channels);
+                return -1;
+            }
+            avctx->channels = avctx->request_channels;
+        }
+    }
+
+    for (blk = 0; blk < ff_eac3_blocks[c->numblkscod]; blk++) {
+        if (parse_audblk(&gbc, c, blk)) {
+            av_log(c->avctx, AV_LOG_ERROR, "Error in parse_audblk\n");
+            return -1;
+        }
+
+        /* recover coefficients if rematrixing is in use */
+        if (c->acmod == AC3_ACMOD_STEREO)
+            ff_ac3_do_rematrixing(c->transform_coeffs,
+                    FFMIN(c->endmant[1], c->endmant[2]),
+                    c->nrematbnds, c->rematflg);
+
+        /* apply scaling to coefficients (dialnorm, dynrng) */
+        for (ch = 1; ch <= c->nfchans + c->lfeon; ch++) {
+            float gain=2.0f;
+            for (i = 0; i < c->endmant[ch]; i++) {
+                c->transform_coeffs[ch][i] *= gain;
+            }
+        }
+
+        do_imdct(c);
+
+        if (avctx->channels != c->num_channels) {
+            ff_ac3_downmix(c->output, c->nfchans, avctx->channels, c->downmix_coeffs);
+        }
+
+        // convert float to 16-bit integer
+        for (ch = 0; ch < avctx->channels; ch++) {
+            for (i = 0; i < AC3_BLOCK_SIZE; i++) {
+                c->output[ch][i] = c->output[ch][i] * c->mul_bias +
+                    c->add_bias;
+            }
+            c->dsp.float_to_int16(c->int_output[ch], c->output[ch],
+                    AC3_BLOCK_SIZE);
+        }
+        for (k = 0; k < AC3_BLOCK_SIZE; k++) {
+            if (c->lfeon) {
+           switch(avctx->channels){
+               case 6:
+                   *(out_samples++) = c->int_output[0][k];   // FL
+                   *(out_samples++) = c->int_output[2][k];   // FR
+                   *(out_samples++) = c->int_output[1][k];   // FC
+                   *(out_samples++) = c->int_output[5][k];   // LFE
+                   *(out_samples++) = c->int_output[3][k];   // BL
+                   *(out_samples++) = c->int_output[4][k];   // BC
+                   break;
+               case 5:
+                   if (c->acmod == 5) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                       *(out_samples++) = c->int_output[4][k];    // LFE
+                       *(out_samples++) = c->int_output[3][k];    // BC
+                   } else {                                    // acmod 6
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[4][k];    // LFE
+                       *(out_samples++) = c->int_output[2][k];    // BL
+                       *(out_samples++) = c->int_output[3][k];    // BR
+                   }
+                   break;
+               case 4:
+                   if (c->acmod == 3) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                       *(out_samples++) = c->int_output[3][k];    // LFE
+                   } else {                                    // acmod 4
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[3][k];    // LFE
+                       *(out_samples++) = c->int_output[2][k];    // BC
+                   }
+                   break;
+               default:
+                   for (i = 0; i < avctx->channels; i++)
+                       *(out_samples++) = c->int_output[i][k];
+           }
+       } else {
+           switch(avctx->channels){
+               case 5:
+                   *(out_samples++) = c->int_output[0][k];   // FL
+                   *(out_samples++) = c->int_output[2][k];   // FR
+                   *(out_samples++) = c->int_output[1][k];   // FC
+                   *(out_samples++) = c->int_output[3][k];   // BL
+                   *(out_samples++) = c->int_output[4][k];   // BC
+                   break;
+               case 4:
+                   if (c->acmod == 5) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                       *(out_samples++) = c->int_output[3][k];    // BC
+                   } else {                                     // acmod 6
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[2][k];    // BL
+                       *(out_samples++) = c->int_output[3][k];    // BR
+                   }
+                   break;
+               case 3:
+                   if (c->acmod == 3) {
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[2][k];    // FR
+                       *(out_samples++) = c->int_output[1][k];    // FC
+                   } else {                                    // acmod 4
+                       *(out_samples++) = c->int_output[0][k];    // FL
+                       *(out_samples++) = c->int_output[1][k];    // FR
+                       *(out_samples++) = c->int_output[2][k];    // BC
+                   }
+                   break;
+               default:
+                   for (i = 0; i < avctx->channels; i++)
+                       *(out_samples++) = c->int_output[i][k];
+           }
+       }
+        }
+    }
+
+    *data_size = ff_eac3_blocks[c->numblkscod] * 256 * avctx->channels * sizeof (int16_t); // TODO is ok?
+
+    return (c->frmsiz+1)*2;
+}
+
+static int eac3_decode_init(AVCodecContext *avctx){
+    EAC3Context *ctx = avctx->priv_data;
+
+    ctx->avctx = avctx;
+    ac3_common_init();
+    ff_ac3_tables_init();
+    av_init_random(0, &ctx->dith_state);
+    ff_mdct_init(&ctx->imdct_256, 8, 1);
+    ff_mdct_init(&ctx->imdct_512, 9, 1);
+    dsputil_init(&ctx->dsp, avctx);
+    if (ctx->dsp.float_to_int16 == ff_float_to_int16_c) {
+        ctx->add_bias = 385.0f;
+        ctx->mul_bias = 1.0f;
+    } else {
+        ctx->add_bias = 0.0f;
+        ctx->mul_bias = 32767.0f;
+    }
+    ff_ac3_window_init(ctx->window);
+    return 0;
+}
+
+static int eac3_decode_end(AVCodecContext *avctx){
+    EAC3Context *ctx = avctx->priv_data;
+    ff_mdct_end(&ctx->imdct_512);
+    ff_mdct_end(&ctx->imdct_256);
+
+    return 0;
+}
+
+AVCodec eac3_decoder = {
+    .name = "E-AC3",
+    .type = CODEC_TYPE_AUDIO,
+    .id = CODEC_ID_EAC3,
+    .priv_data_size = sizeof (EAC3Context),
+    .init = eac3_decode_init,
+    .close = eac3_decode_end,
+    .decode = eac3_decode_frame,
+
+};

--- libavcodec/eac3.h      2007-09-14 00:12:38.000000000 +0200
+++ libavcodec/eac3.h 2007-09-14 00:03:58.000000000 +0200
@@ -0,0 +1,208 @@
+/*
+ * E-AC3 parser
+ * Copyright (c) 2007 Bartlomiej Wolowiec <bartek.wolowiec@gmail.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef EAC3_H
+#define EAC3_H
+
+#include "dsputil.h"
+#include "avcodec.h"
+#include "ac3.h"
+#include "random.h"
+#include "bitstream.h"
+
+/* override ac3.h to include coupling channel */
+#undef AC3_MAX_CHANNELS
+#define AC3_MAX_CHANNELS 7
+
+#define AC3_MAX_COEFS   256
+
+#define AC3_BLOCK_SIZE  256
+#define MAX_BLOCKS 6
+#define MAX_SPX_CODES 18
+
+typedef struct EAC3Context{
+    AVCodecContext *avctx;           ///< Parent context
+    int syncword;
+///@name Bit stream information
+///@{
+    int strmtyp;                     ///< Stream type
+    int substreamid;                 ///< Substream identification
+    int frmsiz;                      ///< Frame size
+    int fscod;                       ///< Sample rate code
+    int fscod2;                      ///< Sample rate code 2
+    int numblkscod;                  ///< Number of audio blocks
+    int acmod;                       ///< Audio coding mode
+    int lfeon;                       ///< Low frequency effect channel on
+    int bsid;                        ///< Bit stream identification
+    float dialnorm[2];               ///< Dialogue normalization
+    int chanmap;                     ///< Custom channel map
+    int mixmdate;                    ///< Mixing meta-data exists
+    int dmixmod;                     ///< Preferred stereo downmix mode
+    int lfemixlevcode;               ///< lfe mix level code exists
+    int lfemixlevcod;                ///< lfe mix level code
+    int pgmscl[2];                   ///< Program scale factor
+    int extpgmscl;                   ///< External program scale factor
+    int mixdef;                      ///< Mix control type
+    int mixdeflen;                   ///< Length of mixing parameter data field
+    int paninfo[2];                  ///< Pan information
+    int frmmixcfginfoe;              ///< Frame mixing configuration information exists
+    int blkmixcfginfo[6];            ///< Block mixing configuration information
+    int infomdate;                   ///< Informational meta-data exists
+///@}
+///@name Audio Frame
+///@{
+    int expstre;                     ///< Exponent strategy syntax enabled
+    int ahte;                        ///< Adaptive hybrid transform enabled
+    int snroffststr;                 ///< SNR offset strategy
+    int snroffst[AC3_MAX_CHANNELS];  ///< SNR offset
+    int transproce;                  ///< Transient pre-noise processing enabled
+    int blkswe;                      ///< Block switch syntax enabled
+    int dithflage;                   ///< Dither flag syntax enabled
+    int bamode;                      ///< Bit allocation model syntax enabled
+    int frmfgaincode;                ///< Fast gain codes enabled
+    int dbaflde;                     ///< Delta bit allocation syntax enabled
+    int skipflde;                    ///< Skip Filed syntax enabled
+    int spxattene;                   ///< Spectral extension attenuation enabled
+    int cplinu[MAX_BLOCKS];          ///< Coupling in use
+    int cplstre[MAX_BLOCKS];         ///< Coupling strategy exists
+    int chexpstr[MAX_BLOCKS][AC3_MAX_CHANNELS];  ///< Channel exponent strategy
+    int chahtinu[AC3_MAX_CHANNELS];      ///< Channel AHT in use
+    int chintransproc[AC3_MAX_CHANNELS]; ///< Channel in transient pre-noise processing
+    int transprocloc[AC3_MAX_CHANNELS];  ///< Transient location relative to start of frame
+    int transproclen[AC3_MAX_CHANNELS];  ///< Transient processing length
+    int chinspxatten[AC3_MAX_CHANNELS];  ///< Channel in spectral extension attenuation process
+    int spxattencod[AC3_MAX_CHANNELS];   ///< spectral extension attenuation code
+    uint32_t blkstrtinfo;            ///< Block start information
+    int ncplblks;
+///@}
+///@name Audio block
+///@{
+    int blksw[AC3_MAX_CHANNELS];     ///< Block switch flag
+    int dithflag[AC3_MAX_CHANNELS];  ///< Dither flag
+    float dynrng[2];                 ///< Dynamic range gain word
+    float downmix_coeffs[AC3_MAX_CHANNELS][2];  ///< stereo downmix coefficients
+    int spxinu;                      ///< spectral extension in use
+    int chinspx[AC3_MAX_CHANNELS];   ///< Channel in spectral extension
+    int spxstrtf;                    ///< Spectral extension start copy frequency code
+    int spxbegf;                     ///< Spectral extension begin frequency code
+    int spxendf;                     ///< Spectral extension end frequency code
+    int spxbndstrc[MAX_SPX_CODES];   ///< Spectral extension band structure
+    int spxcoe[AC3_MAX_CHANNELS];    ///< Spectral extension coordinates exists
+    int spxblnd[AC3_MAX_CHANNELS];   ///< Spectral extension blend
+    int ecplinu;                     ///< Enhanced coupling in use
+    int chincpl[AC3_MAX_CHANNELS];   ///< Channel in coupling
+    int phsflginu;                   ///< Phase flag in use
+    int cplbegf;                     ///< Coupling begin frequency code
+    int cplendf;                     ///< Coupling end frequency code
+    int cplbndstrc[19];              ///< Coupling band structure
+    int ecplbegf;                    ///< Enhanced coupling begin frequency code
+    int ecplendf;                    ///< Enhanced coupling end frequency code
+    int ecplbndstrc[23];             ///< Enhanced coupling band structure
+    int cplcoe[AC3_MAX_CHANNELS];    ///< Coupling coordinates exists
+    int phsflg[18];                  ///< Phase flag
+    int ecplangleintrp;              ///< Enhanced coupling angle interpolation flag
+    int ecplparam1e[AC3_MAX_CHANNELS];   ///< Enhanced coupling parameters 1 exists
+    int ecplparam2e[AC3_MAX_CHANNELS];   ///< Enhanced coupling parameters 2 exists
+    int ecplamp[AC3_MAX_CHANNELS][23];   ///< Enhanced coupling amplitude scaling
+    int ecplangle[AC3_MAX_CHANNELS][23]; ///< Enhanced coupling angle
+    int ecplchaos[AC3_MAX_CHANNELS][23]; ///< Enhanced coupling chaos
+    int ecpltrans[AC3_MAX_CHANNELS];     ///< Enhanced coupling transient present
+    int rematflg[4];                 ///< Rematrixing flag
+    int cplabsexp;                   ///< Coupling absolute exponent
+
+    int fgain[AC3_MAX_CHANNELS];     ///< Channel fast gain
+    int cplleake;                    ///< Coupling leak initialization exists
+    uint8_t deltbae[AC3_MAX_CHANNELS];   ///< Delta bit allocation exists
+    uint8_t deltnseg[AC3_MAX_CHANNELS];  ///< Channel delta bit allocation number of segments
+    uint8_t deltoffst[AC3_MAX_CHANNELS][9]; ///< Channel delta bit allocation offset
+    uint8_t deltlen[AC3_MAX_CHANNELS][9];   ///< Channel delta bit allocation length
+    uint8_t deltba[AC3_MAX_CHANNELS][9];    ///< Channel delta bit allocation
+
+    int got_cplchan;
+    int chgaqgain[256];                             ///< Channel gain adaptive quantization gain
+    float pre_chmant[6][AC3_MAX_CHANNELS][256];     ///< Pre channel mantissas
+
+    int firstspxcos[AC3_MAX_CHANNELS];              ///< First spectral extension coordinates states
+    int firstcplcos[AC3_MAX_CHANNELS];              ///< First coupling coordinates states
+    int firstcplleak;                               ///< First coupling leak state
+///@}
+
+    int nrematbnds;                    ///< Number of rematrixing bands
+    int ncplsubnd;                     ///< Number of coupling sub-bands
+    int ncplbnd;                       ///< Number of structured coupled bands
+
+    int nchgrps[AC3_MAX_CHANNELS];                  ///< Number of fbw channel exponent groups
+    uint8_t dexps[AC3_MAX_CHANNELS][AC3_MAX_COEFS]; ///< Differential exponents
+
+    int strtmant[AC3_MAX_CHANNELS];    ///< Start frequency bin
+    int endmant[AC3_MAX_CHANNELS];     ///< End frequency bin
+    int firstchincpl;
+    int ecpl_start_subbnd;             ///< Enhanced coupling begin frequency
+    int ecpl_end_subbnd;               ///< Enhanced coupling end frequency
+
+    int necplbnd;                      ///< Number of structured enhanced coupling bands
+    int nspxbnds;                      ///< Number of structured spectral extension bands
+    int spxbndsztab[MAX_SPX_CODES];    ///< Sizes of spectral extension bands
+    int nfchans;                       ///< Number of fbw channels
+
+    uint8_t bap[AC3_MAX_CHANNELS][AC3_MAX_COEFS];   ///< bit allocation pointers
+    uint8_t hebap[AC3_MAX_CHANNELS][AC3_MAX_COEFS]; ///< high-efficiency bit allocation pointers for AHT
+    int16_t psd[AC3_MAX_CHANNELS][AC3_MAX_COEFS];   ///< scaled exponents
+    int16_t bndpsd[AC3_MAX_CHANNELS][50];           ///< interpolated exponents
+    int16_t mask[AC3_MAX_CHANNELS][50];             ///< masking values
+
+    float   cplco[AC3_MAX_CHANNELS][18];            ///< coupling coordinates
+    float   spxco[AC3_MAX_CHANNELS][18];            ///< Spectral extension coordinates
+
+    AC3BitAllocParameters bit_alloc_params;         ///< Bit allocation parameters
+
+    AVRandomState dith_state;        ///< for dither generation
+
+    int num_channels;                ///< Total of all channels
+    int lfe_channel;                 ///< Index of LFE channel
+
+    GetBitContext *gbc;              ///< Bitstream reader
+
+    MDCTContext imdct_512;           ///< for 512 sample imdct transform
+    MDCTContext imdct_256;           ///< for 256 sample imdct transform
+    DSPContext  dsp;                 ///< for optimization
+
+    DECLARE_ALIGNED_16(float, transform_coeffs[AC3_MAX_CHANNELS][AC3_MAX_COEFS]);
+    DECLARE_ALIGNED_16(float, delay[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE]);  ///< delay - added to the next block
+    DECLARE_ALIGNED_16(float, window[AC3_BLOCK_SIZE]);               ///< window coefficients
+    DECLARE_ALIGNED_16(float, tmp_output[AC3_BLOCK_SIZE * 24]);      ///< temp storage for output before windowing
+    DECLARE_ALIGNED_16(float, tmp_imdct[AC3_BLOCK_SIZE * 24]);       ///< temp storage for imdct transform
+    DECLARE_ALIGNED_16(float, output[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE]); ///< output after imdct transform and windowing
+    DECLARE_ALIGNED_16(int16_t, int_output[AC3_MAX_CHANNELS][AC3_BLOCK_SIZE]);///< final 16-bit integer output
+
+
+    float add_bias;                  ///< offset for float_to_int16 conversion
+    float mul_bias;                  ///< scaling for float_to_int16 conversion
+}EAC3Context;
+
+/** Channel gain adaptive quantization mode */
+typedef enum {
+    EAC3_GAQ_NO =0,
+    EAC3_GAQ_12,
+    EAC3_GAQ_14,
+    EAC3_GAQ_124
+} EAC3GaqMode;
+
+#endif

--- libavcodec/aac_ac3_parser.c	(revision 10235)
+++ libavcodec/aac_ac3_parser.c	(working copy)
@@ -48,7 +48,7 @@
             s->inbuf_ptr += len;
             buf_size -= len;
             if ((s->inbuf_ptr - s->inbuf) == s->header_size) {
-                len = s->sync(s->inbuf, &channels, &sample_rate, &bit_rate,
+                len = s->sync(avctx, s->inbuf, &channels, &sample_rate, &bit_rate,
                               &samples);
                 if (len == 0) {
                     /* no sync found : move by one byte (inefficient, but simple!) */
@@ -59,7 +59,7 @@
                     /* update codec info */
                     avctx->sample_rate = sample_rate;
                     /* set channels,except if the user explicitly requests 1 or 2 channels, XXX/FIXME this is a bit ugly */
-                    if(avctx->codec_id == CODEC_ID_AC3){
+                    if(avctx->codec_id == CODEC_ID_AC3 || avctx->codec_id == CODEC_ID_EAC3){
                         if(avctx->channels!=1 && avctx->channels!=2){
                             avctx->channels = channels;

--- libavcodec/aac_ac3_parser.h	(revision 10235)
+++ libavcodec/aac_ac3_parser.h	(working copy)
@@ -30,7 +30,7 @@
     uint8_t *inbuf_ptr;
     int frame_size;
     int header_size;
-    int (*sync)(const uint8_t *buf, int *channels, int *sample_rate,
+    int (*sync)(AVCodecContext *avctx, const uint8_t *buf, int *channels, int *sample_rate,
                 int *bit_rate, int *samples);
     uint8_t inbuf[8192]; /* input buffer */
 } AACAC3ParseContext;

--- libavcodec/aac_parser.c	(revision 10235)
+++ libavcodec/aac_parser.c	(working copy)
@@ -38,7 +38,7 @@
 };
 
 
-static int aac_sync(const uint8_t *buf, int *channels, int *sample_rate,
+static int aac_sync(AVCodecContext *avctx, const uint8_t *buf, int *channels, int *sample_rate,
                     int *bit_rate, int *samples)
 {
     GetBitContext bits;

--- libavcodec/ac3_parser.c	(revision 10235)
+++ libavcodec/ac3_parser.c	(working copy)
@@ -84,7 +84,7 @@
     return 0;
 }
 
-static int ac3_sync(const uint8_t *buf, int *channels, int *sample_rate,
+static int ac3_sync(AVCodecContext *avctx, const uint8_t *buf, int *channels, int *sample_rate,
                     int *bit_rate, int *samples)
 {
     int err;
@@ -100,12 +100,16 @@
 
     bsid = hdr.bsid;
     if(bsid <= 10) {             /* Normal AC-3 */
+        if(avctx->codec_id == CODEC_ID_EAC3)
+            avctx->codec_id = CODEC_ID_AC3;
         *sample_rate = hdr.sample_rate;
         *bit_rate = hdr.bit_rate;
         *channels = hdr.channels;
         *samples = AC3_FRAME_SIZE;
         return hdr.frame_size;
     } else if (bsid > 10 && bsid <= 16) { /* Enhanced AC-3 */
+        if(avctx->codec_id == CODEC_ID_AC3)
+            avctx->codec_id = CODEC_ID_EAC3;
         init_get_bits(&bits, &buf[2], (AC3_HEADER_SIZE-2) * 8);
         strmtyp = get_bits(&bits, 2);
         substreamid = get_bits(&bits, 3);
@@ -152,6 +156,13 @@
     return 0;
 }
 
+AVCodecParser eac3_parser = {
+    { CODEC_ID_EAC3 },
+    sizeof(AACAC3ParseContext),
+    ac3_parse_init,
+    ff_aac_ac3_parse,
+    NULL,
+};
 
 AVCodecParser ac3_parser = {
     { CODEC_ID_AC3 },

--- libavcodec/allcodecs.c	(revision 10235)
+++ libavcodec/allcodecs.c	(working copy)
@@ -172,6 +172,7 @@
     REGISTER_DECODER (COOK, cook);
     REGISTER_DECODER (DCA, dca);
     REGISTER_DECODER (DSICINAUDIO, dsicinaudio);
+    REGISTER_DECODER (EAC3, eac3);
     REGISTER_ENCDEC  (FLAC, flac);
     REGISTER_DECODER (IMC, imc);
     REGISTER_ENCDEC  (LIBAMR_NB, libamr_nb);
@@ -266,6 +267,7 @@
     REGISTER_PARSER  (DCA, dca);
     REGISTER_PARSER  (DVBSUB, dvbsub);
     REGISTER_PARSER  (DVDSUB, dvdsub);
+    REGISTER_PARSER  (EAC3, eac3);
     REGISTER_PARSER  (H261, h261);
     REGISTER_PARSER  (H263, h263);
     REGISTER_PARSER  (H264, h264);

--- libavcodec/avcodec.h	(revision 10235)
+++ libavcodec/avcodec.h	(working copy)
@@ -258,6 +258,7 @@
     CODEC_ID_MUSEPACK7,
     CODEC_ID_MLP,
     CODEC_ID_GSM_MS, /* as found in WAV */
+    CODEC_ID_EAC3,
     CODEC_ID_ATRAC3,
     CODEC_ID_VOXWARE,
     CODEC_ID_APE,

--- libavcodec/Makefile	(revision 10235)
+++ libavcodec/Makefile	(working copy)
@@ -63,6 +63,7 @@
 OBJS-$(CONFIG_DVVIDEO_DECODER)         += dv.o
 OBJS-$(CONFIG_DVVIDEO_ENCODER)         += dv.o
 OBJS-$(CONFIG_DXA_DECODER)             += dxa.o
+OBJS-$(CONFIG_EAC3_DECODER)            += eac3dec.o ac3dec.o
 OBJS-$(CONFIG_EIGHTBPS_DECODER)        += 8bps.o
 OBJS-$(CONFIG_FFV1_DECODER)            += ffv1.o rangecoder.o golomb.o
 OBJS-$(CONFIG_FFV1_ENCODER)            += ffv1.o rangecoder.o

--- libavcodec/ac3enc.c	2007-09-26 18:04:18.000000000 +0200
+++ libavcodec/ac3enc.c	2007-09-26 18:38:05.000000000 +0200
@@ -67,6 +67,7 @@
 static int16_t fft_rev[512];
 static int16_t xcos1[128];
 static int16_t xsin1[128];
+static int16_t ch_map[8] = { 0, 1, 2, 4, 5, 3, 6, 7};   // Remapping channels from uncompresed input
 
 #define MDCT_NBITS 9
 #define N         (1 << MDCT_NBITS)
@@ -479,7 +480,8 @@
         for(ch=0;ch<s->nb_all_channels;ch++) {
             ff_ac3_bit_alloc_calc_bap(mask[i][ch], psd[i][ch], 0,
                                       s->nb_coefs[ch], snroffset,
-                                      s->bit_alloc.floor, bap[i][ch]);
+                                      s->bit_alloc.floor, ff_ac3_baptab,
+                                      bap[i][ch]);
             frame_bits += compute_mantissa_size(s, bap[i][ch],
                                                  s->nb_coefs[ch]);
         }
@@ -644,6 +646,21 @@
     avctx->frame_size = AC3_FRAME_SIZE;
 
     ac3_common_init();
+    
+    /* Channel mapping limited to acmod_defs */
+   switch (channels) {
+       case 5:
+           ch_map[3] = 3;   // BLwav_3 -> BLac3_3
+           ch_map[4] = 4;   // BRwav_4 -> BRac3_4
+       case 3:
+       case 6:
+           ch_map[1] = 2;   // FRwav_1 -> FRac3_2
+           ch_map[2] = 1;   // FCwav_2 -> FCac3_1
+           break;
+       case 4:
+           ch_map[3] = 3;   // BCwav_3 -> BCac3_3
+           break;
+   }
 
     /* number of channels */
     if (channels < 1 || channels > 6)
@@ -1170,7 +1187,7 @@
             /* compute input samples */
             memcpy(input_samples, s->last_samples[ch], N/2 * sizeof(int16_t));
             sinc = s->nb_all_channels;
-            sptr = samples + (sinc * (N/2) * i) + ch;
+            sptr = samples + (sinc * (N/2) * i) + ch_map[ch];
             for(j=0;j<N/2;j++) {
                 v = *sptr;
                 input_samples[j + N/2] = v;

--- libavformat/wav.c   2007-09-14 00:02:18.000000000 +0200
+++ libavformat/wav.c   2007-09-25 23:32:14.000000000 +0200
@@ -38,7 +38,7 @@
     offset_t fmt, fact;

     put_tag(pb, "RIFF");
-    put_le32(pb, 0); /* file length */
+    put_le32(pb, 36); // by the moment header length send
     put_tag(pb, "WAVE");

     /* format header */
